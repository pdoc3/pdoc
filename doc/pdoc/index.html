<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>pdoc API documentation</title>
<meta name="description" content="Python package `pdoc` provides types, functions, and a command-line
interface for accessing public documentation of Python modules, and
for presenting â€¦">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<link rel="preconnect" href="https://www.google.com">
<script async src="https://cse.google.com/cse.js?cx=017837193012385208679:pey8ky8gdqw"></script>
<style>
.gsc-control-cse {padding:0 !important;margin-top:1em}
body.gsc-overflow-hidden #sidebar {overflow: visible;}
</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:#555;padding-bottom:.5em;border-bottom:1px solid silver}.homelink:hover{color:inherit}.homelink img{max-width:20%;max-height:5em;margin:auto;margin-bottom:.3em}</style>
<link rel="canonical" href="https://pdoc3.github.io/pdoc/doc/pdoc/">
<link rel="icon" href="https://pdoc3.github.io/pdoc/logo.png">
<script async src='https://www.googletagmanager.com/gtag/js?id=G-BKZPJPR558'></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}gtag('js',new Date());gtag('config','G-BKZPJPR558');</script><script data-ad-client="ca-pub-2900001379782823" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>pdoc</code></h1>
</header>
<section id="section-intro">
<p>Python package <code><a title="pdoc" href="#pdoc">pdoc</a></code> provides types, functions, and a command-line
interface for accessing public documentation of Python modules, and
for presenting it in a user-friendly, industry-standard open format.
It is best suited for small- to medium-sized projects with tidy,
hierarchical APIs.</p>
<p><code><a title="pdoc" href="#pdoc">pdoc</a></code> extracts documentation of:</p>
<ul>
<li>modules (including submodules),</li>
<li>functions (including methods, properties, coroutines &hellip;),</li>
<li>classes, and</li>
<li>variables (including globals, class variables, and instance variables).</li>
</ul>
<p>Documentation is extracted from live objects' <a href="https://docs.python.org/3/glossary.html#term-docstring">docstrings</a>
using Python's <code>__doc__</code> attribute<sup id="fnref:execution"><a class="footnote-ref" href="#fn:execution">1</a></sup>. Documentation for
variables is found by examining objects' abstract syntax trees.</p>
<h2 id="what-objects-are-documented">What objects are documented?</h2>
<p><code><a title="pdoc" href="#pdoc">pdoc</a></code> only extracts <em>public API</em> documentation.<sup id="fnref:public"><a class="footnote-ref" href="#fn:public">2</a></sup>
Code objects (modules, variables, functions, classes, methods) are considered
public in the modules where they are defined (vs. imported from somewhere else)
as long as their <em>identifiers don't begin with an underscore</em> ( _ ).<sup id="fnref:private"><a class="footnote-ref" href="#fn:private">3</a></sup>
If a module defines <a href="https://docs.python.org/3/tutorial/modules.html#importing-from-a-package"><code>__all__</code></a>, then only the identifiers contained
in this list are considered public, regardless of where they were defined.</p>
<p>This can be fine-tuned through <a href="#overriding-docstrings-with-__pdoc__"><code>__pdoc__</code> dict</a>.</p>
<h2 id="where-does-pdoc-get-documentation-from">Where does <code><a title="pdoc" href="#pdoc">pdoc</a></code> get documentation from?</h2>
<p>In Python, objects like modules, functions, classes, and methods
have a special attribute <code>__doc__</code> which contains that object's
documentation string (<a href="https://docs.python.org/3/glossary.html#term-docstring">docstring</a>).
For example, the following code defines a function with a docstring
and shows how to access its contents:</p>
<pre><code>&gt;&gt;&gt; def test():
...     """This is a docstring."""
...     pass
...
&gt;&gt;&gt; test.__doc__
'This is a docstring.'
</code></pre>
<p>It's pretty much the same with classes and modules.
See <a href="https://www.python.org/dev/peps/pep-0257/">PEP-257</a> for Python docstring conventions.</p>
<p>These docstrings are set as descriptions for each module, class,
function, and method listed in the documentation produced by <code><a title="pdoc" href="#pdoc">pdoc</a></code>.</p>
<p><code><a title="pdoc" href="#pdoc">pdoc</a></code> extends the standard use of docstrings in Python in two
important ways: by allowing methods to inherit docstrings, and
by introducing syntax for docstrings for variables.</p>
<h3 id="docstrings-inheritance">Docstrings inheritance</h3>
<p><code><a title="pdoc" href="#pdoc">pdoc</a></code> considers methods' docstrings inherited from superclass methods',
following the normal class inheritance patterns.
Consider the following code example:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class A:
...     def test(self):
...         &quot;&quot;&quot;Docstring for A.&quot;&quot;&quot;
...         pass
...
&gt;&gt;&gt; class B(A):
...     def test(self):
...         pass
...
&gt;&gt;&gt; A.test.__doc__
'Docstring for A.'
&gt;&gt;&gt; B.test.__doc__
None
</code></pre>
<p>In Python, the docstring for <code>B.test</code> doesn't exist, even though a
docstring was defined for <code>A.test</code>.
Contrary, when <code><a title="pdoc" href="#pdoc">pdoc</a></code> generates documentation for code such as above,
it will automatically attach the docstring for <code>A.test</code> to
<code>B.test</code> if the latter doesn't define its own.
In the default HTML template, such inherited docstrings are greyed out.</p>
<h3 id="docstrings-for-variables">Docstrings for variables</h3>
<p>Python by itself <a href="http://www.python.org/dev/peps/pep-0224">doesn't allow docstrings attached to variables</a>.
However, <code><a title="pdoc" href="#pdoc">pdoc</a></code> supports documenting module (or global)
variables, class variables, and object instance variables via
two different mechanisms: <a href="http://www.python.org/dev/peps/pep-0224">PEP-224</a> and <code>#:</code> doc-comments.</p>
<p>For example:</p>
<pre><code class="language-python">module_variable = 1
&quot;&quot;&quot;PEP 224 docstring for module_variable.&quot;&quot;&quot;

class C:
    #: Documentation comment for class_variable
    #: spanning over three lines.
    class_variable = 2  #: Assignment line is included.

    def __init__(self):
        #: Instance variable's doc-comment
        self.variable = 3
        &quot;&quot;&quot;But note, PEP 224 docstrings take precedence.&quot;&quot;&quot;
</code></pre>
<p>While the resulting variables have no <code>__doc__</code> attribute,
<code><a title="pdoc" href="#pdoc">pdoc</a></code> compensates by reading the source code (when available)
and parsing the syntax tree.</p>
<p>By convention, variables defined in a class' <code>__init__</code> method
and attached to <code>self</code> are considered and documented as
<em>instance</em> variables.</p>
<p>Class and instance variables can also <a href="#docstrings-inheritance">inherit docstrings</a>.</p>
<h2 id="overriding-docstrings-with-__pdoc__">Overriding docstrings with <code>__pdoc__</code></h2>
<p>Docstrings for objects can be disabled, overridden, or whitelisted with a special
module-level dictionary <code>__pdoc__</code>. The <em>keys</em>
should be string identifiers within the scope of the module or,
alternatively, fully-qualified reference names. E.g. for instance
variable <code>self.variable</code> of class <code>C</code>, its module-level identifier is
<code>'C.variable'</code>, and <code>some_package.module.C.variable</code> its refname.</p>
<p>If <code>__pdoc__[key] = False</code>, then <code>key</code> (and its members) will be
<strong>excluded from the documentation</strong> of the module.</p>
<p>Conversely, if <code>__pdoc__[key] = True</code>, then <code>key</code> (and its public members) will be
<strong>included in the documentation</strong> of the module. This can be used to
include documentation of <a href="#what-objects-are-documented">private objects</a>,
including special functions such as <code>__call__</code>, which are ignored by default.</p>
<p>Alternatively, the <em>values</em> of <code>__pdoc__</code> can be the <strong>overriding docstrings</strong>.
This feature is useful when there's no feasible way of
attaching a docstring to something. A good example is a
<a href="https://docs.python.org/3/library/collections.html#collections.namedtuple">namedtuple</a>:</p>
<pre><code class="language-python">__pdoc__ = {}

Table = namedtuple('Table', ['types', 'names', 'rows'])
__pdoc__['Table.types'] = 'Types for each column in the table.'
__pdoc__['Table.names'] = 'The names of each column in the table.'
__pdoc__['Table.rows'] = 'Lists corresponding to each row in the table.'
</code></pre>
<p><code><a title="pdoc" href="#pdoc">pdoc</a></code> will then show <code>Table</code> as a class with documentation for the
<code>types</code>, <code>names</code> and <code>rows</code> members.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The assignments to <code>__pdoc__</code> need to be placed where they'll be
executed when the module is imported. For example, at the top level
of a module or in the definition of a class.</p>
</div>
<h2 id="supported-docstring-formats">Supported Docstring Formats</h2>
<p>Currently, pure Markdown (with <a href="https://python-markdown.github.io/extensions/#officially-supported-extensions">extensions</a>), <a href="https://numpydoc.readthedocs.io/">numpydoc</a>,
and <a href="http://google.github.io/styleguide/pyguide.html#38-comments-and-docstrings">Google-style</a> docstrings formats are supported,
along with some <a href="#supported-rest-directives"><abbr title="reStructuredText">reST</abbr> directives</a>.</p>
<p>Additionally, if <code>latex_math</code> <a href="#custom-templates">template config</a> option is enabled,
LaTeX math syntax is supported when placed between
<a href="https://docs.mathjax.org/en/latest/input/tex/delimiters.html">recognized delimiters</a>: <code>\(...\)</code> for inline equations and
<code>\[...\]</code> or <code>$$...$$</code> for block equations. Note, you need to escape
your backslashes in Python docstrings (<code>\\(</code>, <code>\\frac{}{}</code>, &hellip;)
or, alternatively, use <a href="https://www.journaldev.com/23598/python-raw-string">raw string literals</a>.</p>
<h3 id="supported-rest-directives">Supported <abbr title="reStructuredText">reST</abbr> directives</h3>
<p>The following <abbr title="reStructuredText">reST</abbr> directives should work:</p>
<ul>
<li>specific and generic <a href="http://docutils.sourceforge.net/docs/ref/rst/directives.html#admonitions">admonitions</a> (attention, caution, danger,
error, hint, important, note, tip, warning, admonition),</li>
<li><a href="http://docutils.sourceforge.net/docs/ref/rst/directives.html#images"><code>.. image::</code></a> or <code>.. figure::</code> (without options),</li>
<li><a href="http://docutils.sourceforge.net/docs/ref/rst/directives.html#including-an-external-document-fragment"><code>.. include::</code></a>, with support for the options:
<code>:start-line:</code>, <code>:end-line:</code>, <code>:start-after:</code> and <code>:end-before:</code>.</li>
<li><a href="http://docutils.sourceforge.net/docs/ref/rst/directives.html#math"><code>.. math::</code></a></li>
<li><code>.. versionadded::</code></li>
<li><code>.. versionchanged::</code></li>
<li><code>.. deprecated::</code></li>
<li><code>.. todo::</code></li>
</ul>
<h2 id="linking-to-other-identifiers">Linking To Other Identifiers</h2>
<p>In your documentation, you may refer to other identifiers in
your modules. When exporting to HTML, linking is automatically
done whenever you surround an identifier with <a href="https://en.wikipedia.org/wiki/Backtick">backticks</a> ( ` ).
Unless within the current module,
the identifier name must be fully qualified, for example
<code>`pdoc.Doc.docstring`</code> is correct (and will link to
<code><a title="pdoc.Doc.docstring" href="#pdoc.Doc.docstring">Doc.docstring</a></code>) while <code>`Doc.docstring`</code>
only works within <code><a title="pdoc" href="#pdoc">pdoc</a></code> module.</p>
<h2 id="command-line-interface">Command-line interface</h2>
<p><code><a title="pdoc" href="#pdoc">pdoc</a></code> includes a feature-rich "binary" program for producing
HTML and plain text documentation of your modules.
For example, to produce HTML documentation of your whole package
in subdirectory 'build' of the current directory, using the default
HTML template, run:</p>
<pre><code class="language-shell">$ pdoc --html --output-dir build my_package
</code></pre>
<p>If you want to omit the source code preview, run:</p>
<pre><code class="language-shell">$ pdoc --html --config show_source_code=False my_package
</code></pre>
<p>Find additional template configuration tunables in <a href="#custom-templates">custom templates</a>
section below.</p>
<p>To run a local HTTP server while developing your package or writing
docstrings for it, run:</p>
<pre><code class="language-shell">$ pdoc --http : my_package
</code></pre>
<p>To re-build documentation as part of your continuous integration (CI)
best practice, i.e. ensuring all reference links are correct and
up-to-date, make warnings error loudly by settings the environment
variable <a href="https://docs.python.org/3/using/cmdline.html#envvar-PYTHONWARNINGS"><code>PYTHONWARNINGS</code></a> before running pdoc:</p>
<pre><code class="language-shell">$ export PYTHONWARNINGS='error::UserWarning'
</code></pre>
<p>For brief usage instructions, type:</p>
<pre><code class="language-shell">$ pdoc --help
</code></pre>
<p>Even more usage examples can be found in the <a href="https://github.com/pdoc3/pdoc/issues?q=is%3Aissue+label%3Aquestion">FAQ</a>.</p>
<h2 id="programmatic-usage">Programmatic Usage</h2>
<p>The main entry point is <code><a title="pdoc.Module" href="#pdoc.Module">Module</a></code> which wraps a module object
and recursively imports and wraps any submodules and their members.</p>
<p>After all related modules are wrapped (related modules are those that
share the same <code><a title="pdoc.Context" href="#pdoc.Context">Context</a></code>), you need to call
<code><a title="pdoc.link_inheritance" href="#pdoc.link_inheritance">link_inheritance()</a></code> with the used <code><a title="pdoc.Context" href="#pdoc.Context">Context</a></code> instance to
establish class inheritance links.</p>
<p>Afterwards, you can use <code><a title="pdoc.Module.html" href="#pdoc.Module.html">Module.html()</a></code> and <code><a title="pdoc.Module.text" href="#pdoc.Module.text">Module.text()</a></code>
methods to output documentation in the desired format.
For example:</p>
<pre><code class="language-python">import pdoc

modules = ['a', 'b']  # Public submodules are auto-imported
context = pdoc.Context()

modules = [pdoc.Module(mod, context=context)
           for mod in modules]
pdoc.link_inheritance(context)

def recursive_htmls(mod):
    yield mod.name, mod.html()
    for submod in mod.submodules():
        yield from recursive_htmls(submod)

for mod in modules:
    for module_name, html in recursive_htmls(mod):
        ...  # Process
</code></pre>
<p>When documenting a single module, you might find
functions <code><a title="pdoc.html" href="#pdoc.html">html()</a></code> and <code><a title="pdoc.text" href="#pdoc.text">text()</a></code> handy.
For importing arbitrary modules/files, use <code><a title="pdoc.import_module" href="#pdoc.import_module">import_module()</a></code>.</p>
<p>Alternatively, use the <a href="#command-line-interface">runnable script</a> included with this package.</p>
<h2 id="custom-templates">Custom Templates</h2>
<p>To override the built-in HTML/CSS and plain text templates, copy
the relevant templates from <code>pdoc/templates</code> directory into a directory
of your choosing and edit them. When you run <a href="#command-line-interface">pdoc command</a>
afterwards, pass the directory path as a parameter to the
<code>--template-dir</code> switch.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>If you find you only need to apply minor alterations to the HTML template,
see if you can do so by overriding just some of the following, placeholder
sub-templates:</p>
<ul>
<li><a href="https://github.com/pdoc3/pdoc/blob/master/pdoc/templates/config.mako"><em>config.mako</em></a>: Basic template configuration, affects the way templates
are rendered.</li>
<li><em>head.mako</em>: Included just before <code>&lt;/head&gt;</code>. Best for adding resources and styles.</li>
<li><em>logo.mako</em>: Included at the very top of the navigation sidebar. Empty by default.</li>
<li><em>credits.mako</em>: Included in the footer, right before pdoc version string.</li>
</ul>
<p>See <a href="https://github.com/pdoc3/pdoc/tree/master/pdoc/templates">default template files</a> for reference.</p>
</div>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>You can also alter individual <a href="https://github.com/pdoc3/pdoc/blob/master/pdoc/templates/config.mako"><em>config.mako</em></a> preferences using the
<code>--config</code> command-line switch.</p>
</div>
<p>If working with <code><a title="pdoc" href="#pdoc">pdoc</a></code> programmatically, <em>prepend</em> the directory with
modified templates into the <code>directories</code> list of the
<code><a title="pdoc.tpl_lookup" href="#pdoc.tpl_lookup">tpl_lookup</a></code> object.</p>
<h2 id="compatibility">Compatibility</h2>
<p><code><a title="pdoc" href="#pdoc">pdoc</a></code> requires Python 3.7+.
The last version to support Python 2.x is <a href="https://pypi.org/project/pdoc3/0.3.13/">pdoc3 0.3.x</a>.</p>
<h2 id="contributing">Contributing</h2>
<p><code><a title="pdoc" href="#pdoc">pdoc</a></code> is <a href="https://github.com/pdoc3/pdoc">on GitHub</a>. Bug reports and pull requests are welcome.</p>
<h2 id="license">License</h2>
<p><code><a title="pdoc" href="#pdoc">pdoc</a></code> is licensed under the terms of GNU <a href="https://www.gnu.org/licenses/agpl-3.0.html" rel="license">AGPL-3.0</a> or later,
meaning you can use it for any reasonable purpose and remain in
complete ownership of all the documentation you produce,
but you are also encouraged to make sure any upgrades to <code><a title="pdoc" href="#pdoc">pdoc</a></code>
itself find their way back to the community.</p>
<div class="footnote">
<hr>
<ol>
<li id="fn:execution">
<p>Documented modules are <em>executed</em> in order to provide <code>__doc__</code>
attributes. Any <a href="https://stackoverflow.com/questions/19578308/what-is-the-benefit-of-using-main-method-in-python/19578335#19578335">non-fenced</a> global code in imported modules will
<em>affect the current runtime environment</em>.&#160;<a class="footnote-backref" href="#fnref:execution" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:public">
<p>Here, public API refers to the API that is made available
to your project end-users, not the public API e.g. of a
private class that can be reasonably extended elsewhere
by your project developers.&#160;<a class="footnote-backref" href="#fnref:public" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
<li id="fn:private">
<p>Prefixing private, implementation-specific objects with
an underscore is <a href="https://docs.python.org/3/tutorial/classes.html#private-variables">a common convention</a>.&#160;<a class="footnote-backref" href="#fnref:private" title="Jump back to footnote 3 in the text">&#8617;</a></p>
</li>
</ol>
</div>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="pdoc.cli" href="cli.html">pdoc.cli</a></code></dt>
<dd>
<div class="desc"><p>pdoc's CLI interface and helper functions.</p></div>
</dd>
<dt><code class="name"><a title="pdoc.html_helpers" href="html_helpers.html">pdoc.html_helpers</a></code></dt>
<dd>
<div class="desc"><p>Helper functions for HTML output.</p></div>
</dd>
<dt><code class="name"><a title="pdoc.test" href="test/index.html">pdoc.test</a></code></dt>
<dd>
<div class="desc"><p>Unit tests for pdoc package.</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="pdoc.tpl_lookup"><code class="name">var <span class="ident">tpl_lookup</span></code></dt>
<dd>
<div class="desc"><p>A <code>mako.lookup.TemplateLookup</code> object that knows how to load templates
from the file system. You may add additional paths by modifying the
object's <code>directories</code> attribute.</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pdoc.html"><code class="name flex">
<span>def <span class="ident">html</span></span>(<span>module_name, docfilter=None, reload=False, skip_errors=False, **kwargs) â€‘>Â str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdoc3/pdoc/blob/5570f9a425d7cac7f7071c4c4d17a9edae20dc3d/pdoc/__init__.py#L165-L178" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def html(module_name, docfilter=None, reload=False, skip_errors=False, **kwargs) -&gt; str:
    &#34;&#34;&#34;
    Returns the documentation for the module `module_name` in HTML
    format. The module must be a module or an importable string.

    `docfilter` is an optional predicate that controls which
    documentation objects are shown in the output. It is a function
    that takes a single argument (a documentation object) and returns
    `True` or `False`. If `False`, that object will not be documented.
    &#34;&#34;&#34;
    mod = Module(import_module(module_name, reload=reload, skip_errors=False),
                 docfilter=docfilter, skip_errors=skip_errors)
    link_inheritance()
    return mod.html(**kwargs)</code></pre>
</details>
<div class="desc"><p>Returns the documentation for the module <code>module_name</code> in HTML
format. The module must be a module or an importable string.</p>
<p><code>docfilter</code> is an optional predicate that controls which
documentation objects are shown in the output. It is a function
that takes a single argument (a documentation object) and returns
<code>True</code> or <code>False</code>. If <code>False</code>, that object will not be documented.</p></div>
</dd>
<dt id="pdoc.import_module"><code class="name flex">
<span>def <span class="ident">import_module</span></span>(<span>module:Â strÂ |Â module, *, reload:Â boolÂ =Â False, skip_errors:Â boolÂ =Â False) â€‘>Â module</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdoc3/pdoc/blob/5570f9a425d7cac7f7071c4c4d17a9edae20dc3d/pdoc/__init__.py#L198-L245" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def import_module(
        module: Union[str, ModuleType],
        *,
        reload: bool = False,
        skip_errors: bool = False,
) -&gt; ModuleType:
    &#34;&#34;&#34;
    Return module object matching `module` specification (either a python
    module path or a filesystem path to file/directory).
    &#34;&#34;&#34;
    @contextmanager
    def _module_path(module):
        from os.path import abspath, dirname, isfile, isdir, split
        path = &#39;_pdoc_dummy_nonexistent&#39;
        module_name = inspect.getmodulename(module)
        if isdir(module):
            path, module = split(abspath(module))
        elif isfile(module) and module_name:
            path, module = dirname(abspath(module)), module_name
        try:
            sys.path.insert(0, path)
            yield module
        finally:
            sys.path.remove(path)

    if isinstance(module, Module):
        module = module.obj
    if isinstance(module, str):
        with _module_path(module) as module_path:
            try:
                module = importlib.import_module(module_path)
            except Exception as e:
                msg = f&#39;Error importing {module!r}: {e.__class__.__name__}: {e}&#39;
                if not skip_errors:
                    raise ImportError(msg)
                warn(msg, category=Module.ImportWarning, stacklevel=2)
                module = ModuleType(module_path)

    assert inspect.ismodule(module)
    # If this is pdoc itself, return without reloading. Otherwise later
    # `isinstance(..., pdoc.Doc)` calls won&#39;t work correctly.
    if reload and not module.__name__.startswith(__name__):
        module = importlib.reload(module)
        # We recursively reload all submodules, in case __all_ is used - cf. issue #264
        for mod_key, mod in list(sys.modules.items()):
            if mod_key.startswith(module.__name__):
                importlib.reload(mod)
    return module</code></pre>
</details>
<div class="desc"><p>Return module object matching <code>module</code> specification (either a python
module path or a filesystem path to file/directory).</p></div>
</dd>
<dt id="pdoc.link_inheritance"><code class="name flex">
<span>def <span class="ident">link_inheritance</span></span>(<span>context:Â <a title="pdoc.Context" href="#pdoc.Context">Context</a>Â |Â NoneÂ =Â None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdoc3/pdoc/blob/5570f9a425d7cac7f7071c4c4d17a9edae20dc3d/pdoc/__init__.py#L483-L502" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def link_inheritance(context: Optional[Context] = None):
    &#34;&#34;&#34;
    Link inheritance relationsships between `pdoc.Class` objects
    (and between their members) of all `pdoc.Module` objects that
    share the provided `context` (`pdoc.Context`).

    You need to call this if you expect `pdoc.Doc.inherits` and
    inherited `pdoc.Doc.docstring` to be set correctly.
    &#34;&#34;&#34;
    if context is None:
        context = _global_context

    graph = {cls: set(cls.mro(only_documented=True))
             for cls in _filter_type(Class, context)}

    for cls in _toposort(graph):
        cls._fill_inheritance()

    for module in _filter_type(Module, context):
        module._link_inheritance()</code></pre>
</details>
<div class="desc"><p>Link inheritance relationsships between <code><a title="pdoc.Class" href="#pdoc.Class">Class</a></code> objects
(and between their members) of all <code><a title="pdoc.Module" href="#pdoc.Module">Module</a></code> objects that
share the provided <code>context</code> (<code><a title="pdoc.Context" href="#pdoc.Context">Context</a></code>).</p>
<p>You need to call this if you expect <code><a title="pdoc.Doc.inherits" href="#pdoc.Doc.inherits">Doc.inherits</a></code> and
inherited <code><a title="pdoc.Doc.docstring" href="#pdoc.Doc.docstring">Doc.docstring</a></code> to be set correctly.</p></div>
</dd>
<dt id="pdoc.maybe_lru_cache"><code class="name flex">
<span>def <span class="ident">maybe_lru_cache</span></span>(<span>func)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdoc3/pdoc/blob/5570f9a425d7cac7f7071c4c4d17a9edae20dc3d/pdoc/__init__.py#L1282-L1292" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def maybe_lru_cache(func):
    cached_func = lru_cache()(func)

    @wraps(func)
    def wrapper(*args):
        try:
            return cached_func(*args)
        except TypeError:
            return func(*args)

    return wrapper</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="pdoc.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdoc3/pdoc/blob/5570f9a425d7cac7f7071c4c4d17a9edae20dc3d/pdoc/__init__.py#L96-L111" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def reset():
    &#34;&#34;&#34;Resets the global `pdoc.Context` to the initial (empty) state.&#34;&#34;&#34;
    global _global_context
    _global_context.clear()

    # Clear LRU caches
    for func in (_get_type_hints,
                 _is_blacklisted,
                 _is_whitelisted):
        func.cache_clear()
    for cls in (Doc, Module, Class, Function, Variable, External):
        for _, method in inspect.getmembers(cls):
            if isinstance(method, property):
                method = method.fget
            if hasattr(method, &#39;cache_clear&#39;):
                method.cache_clear()</code></pre>
</details>
<div class="desc"><p>Resets the global <code><a title="pdoc.Context" href="#pdoc.Context">Context</a></code> to the initial (empty) state.</p></div>
</dd>
<dt id="pdoc.text"><code class="name flex">
<span>def <span class="ident">text</span></span>(<span>module_name, docfilter=None, reload=False, skip_errors=False, **kwargs) â€‘>Â str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdoc3/pdoc/blob/5570f9a425d7cac7f7071c4c4d17a9edae20dc3d/pdoc/__init__.py#L181-L195" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def text(module_name, docfilter=None, reload=False, skip_errors=False, **kwargs) -&gt; str:
    &#34;&#34;&#34;
    Returns the documentation for the module `module_name` in plain
    text format suitable for viewing on a terminal.
    The module must be a module or an importable string.

    `docfilter` is an optional predicate that controls which
    documentation objects are shown in the output. It is a function
    that takes a single argument (a documentation object) and returns
    `True` or `False`. If `False`, that object will not be documented.
    &#34;&#34;&#34;
    mod = Module(import_module(module_name, reload=reload, skip_errors=False),
                 docfilter=docfilter, skip_errors=skip_errors)
    link_inheritance()
    return mod.text(**kwargs)</code></pre>
</details>
<div class="desc"><p>Returns the documentation for the module <code>module_name</code> in plain
text format suitable for viewing on a terminal.
The module must be a module or an importable string.</p>
<p><code>docfilter</code> is an optional predicate that controls which
documentation objects are shown in the output. It is a function
that takes a single argument (a documentation object) and returns
<code>True</code> or <code>False</code>. If <code>False</code>, that object will not be documented.</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pdoc.Class"><code class="flex name class">
<span>class <span class="ident">Class</span></span>
<span>(</span><span>name:Â str,<br>module:Â <a title="pdoc.Module" href="#pdoc.Module">Module</a>,<br>obj,<br>*,<br>docstring:Â strÂ |Â NoneÂ =Â None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdoc3/pdoc/blob/5570f9a425d7cac7f7071c4c4d17a9edae20dc3d/pdoc/__init__.py#L1031-L1279" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class Class(Doc):
    &#34;&#34;&#34;
    Representation of a class&#39; documentation.
    &#34;&#34;&#34;
    def __init__(self, name: str, module: Module, obj, *, docstring: Optional[str] = None):
        assert inspect.isclass(obj)

        if docstring is None:
            init_doc = inspect.getdoc(obj.__init__) or &#39;&#39;
            if init_doc == object.__init__.__doc__:
                init_doc = &#39;&#39;
            docstring = f&#39;{inspect.getdoc(obj) or &#34;&#34;}\n\n{init_doc}&#39;.strip()

        super().__init__(name, module, obj, docstring=docstring)

        self.doc: Dict[str, Union[Function, Variable]] = {}
        &#34;&#34;&#34;A mapping from identifier name to a `pdoc.Doc` objects.&#34;&#34;&#34;

        # Annotations for filtering.
        # Use only own, non-inherited annotations (the rest will be inherited)
        annotations = getattr(self.obj, &#39;__annotations__&#39;, {})

        public_objs = []
        for _name, obj in _getmembers_all(self.obj):
            # Filter only *own* members. The rest are inherited
            # in Class._fill_inheritance()
            if ((_name in self.obj.__dict__ or
                 _name in annotations) and
                    (_is_public(_name) or
                     _is_whitelisted(_name, self))):

                if _is_blacklisted(_name, self):
                    self.module._context.blacklisted.add(f&#39;{self.refname}.{_name}&#39;)
                    continue

                obj = inspect.unwrap(obj)
                public_objs.append((_name, obj))

        def definition_order_index(
                name,
                _annot_index=list(annotations).index,
                _dict_index=list(self.obj.__dict__).index):
            try:
                return _dict_index(name)
            except ValueError:
                pass
            try:
                return _annot_index(name) - len(annotations)  # sort annotated first
            except ValueError:
                return 9e9

        public_objs.sort(key=lambda i: definition_order_index(i[0]))

        var_docstrings, instance_var_docstrings = _pep224_docstrings(self)

        # Convert the public Python objects to documentation objects.
        for name, obj in public_objs:
            if _is_function(obj):
                self.doc[name] = Function(
                    name, self.module, obj, cls=self)
            else:
                self.doc[name] = Variable(
                    name, self.module,
                    docstring=(
                        var_docstrings.get(name) or
                        (inspect.isclass(obj) or _is_descriptor(obj)) and inspect.getdoc(obj)),
                    cls=self,
                    kind=&#34;prop&#34; if isinstance(obj, property) else &#34;var&#34;,
                    obj=_is_descriptor(obj) and obj or None,
                    instance_var=(_is_descriptor(obj) or
                                  name in getattr(self.obj, &#39;__slots__&#39;, ()) or
                                  (is_dataclass(self.obj) and name in annotations)))

        for name, docstring in instance_var_docstrings.items():
            self.doc[name] = Variable(
                name, self.module, docstring, cls=self,
                obj=getattr(self.obj, name, None),
                instance_var=True)

    @staticmethod
    def _method_type(cls: type, name: str):
        &#34;&#34;&#34;
        Returns `None` if the method `name` of class `cls`
        is a regular method. Otherwise, it returns
        `classmethod` or `staticmethod`, as appropriate.
        &#34;&#34;&#34;
        func = getattr(cls, name, None)
        if inspect.ismethod(func):
            # If the function is already bound, it&#39;s a classmethod.
            # Regular methods are not bound before initialization.
            return classmethod
        for c in inspect.getmro(cls):
            if name in c.__dict__:
                if isinstance(c.__dict__[name], staticmethod):
                    return staticmethod
                return None
        raise RuntimeError(f&#34;{cls}.{name} not found&#34;)

    @property
    def refname(self) -&gt; str:
        return f&#39;{self.module.name}.{self.qualname}&#39;

    def mro(self, only_documented=False) -&gt; List[&#39;Class&#39;]:
        &#34;&#34;&#34;
        Returns a list of ancestor (superclass) documentation objects
        in method resolution order.

        The list will contain objects of type `pdoc.Class`
        if the types are documented, and `pdoc.External` otherwise.
        &#34;&#34;&#34;
        classes = [cast(Class, self.module.find_class(c))
                   for c in inspect.getmro(self.obj)
                   if c not in (self.obj, object)]
        if self in classes:
            # This can contain self in case of a class inheriting from
            # a class with (previously) the same name. E.g.
            #
            #     class Loc(namedtuple(&#39;Loc&#39;, &#39;lat lon&#39;)): ...
            #
            # We remove it from ancestors so that toposort doesn&#39;t break.
            classes.remove(self)
        if only_documented:
            classes = _filter_type(Class, classes)
        return classes

    def subclasses(self) -&gt; List[&#39;Class&#39;]:
        &#34;&#34;&#34;
        Returns a list of subclasses of this class that are visible to the
        Python interpreter (obtained from `type.__subclasses__()`).

        The objects in the list are of type `pdoc.Class` if available,
        and `pdoc.External` otherwise.
        &#34;&#34;&#34;
        return sorted(cast(Class, self.module.find_class(c))
                      for c in type.__subclasses__(self.obj))

    def params(self, *, annotate=False, link=None) -&gt; List[str]:
        &#34;&#34;&#34;
        Return a list of formatted parameters accepted by the
        class constructor (method `__init__`). See `pdoc.Function.params`.
        &#34;&#34;&#34;
        name = self.name + &#39;.__init__&#39;
        qualname = self.qualname + &#39;.__init__&#39;
        refname = self.refname + &#39;.__init__&#39;
        exclusions = self.module.__pdoc__
        if name in exclusions or qualname in exclusions or refname in exclusions:
            return []

        return Function._params(self, annotate=annotate, link=link, module=self.module)

    def _filter_doc_objs(self, type: Type[T], include_inherited=True,
                         filter_func: Callable[[T], bool] = lambda x: True,
                         sort=True) -&gt; List[T]:
        result = [obj for obj in _filter_type(type, self.doc)
                  if (include_inherited or not obj.inherits) and filter_func(obj)]
        return sorted(result) if sort else result

    def class_variables(self, include_inherited=True, sort=True) -&gt; List[&#39;Variable&#39;]:
        &#34;&#34;&#34;
        Returns an optionally-sorted list of `pdoc.Variable` objects that
        represent this class&#39; class variables.
        &#34;&#34;&#34;
        return self._filter_doc_objs(
            Variable, include_inherited, lambda dobj: not dobj.instance_var,
            sort)

    def instance_variables(self, include_inherited=True, sort=True) -&gt; List[&#39;Variable&#39;]:
        &#34;&#34;&#34;
        Returns an optionally-sorted list of `pdoc.Variable` objects that
        represent this class&#39; instance variables. Instance variables
        are those defined in a class&#39;s `__init__` as `self.variable = ...`.
        &#34;&#34;&#34;
        return self._filter_doc_objs(
            Variable, include_inherited, lambda dobj: dobj.instance_var,
            sort)

    def methods(self, include_inherited=True, sort=True) -&gt; List[&#39;Function&#39;]:
        &#34;&#34;&#34;
        Returns an optionally-sorted list of `pdoc.Function` objects that
        represent this class&#39; methods.
        &#34;&#34;&#34;
        return self._filter_doc_objs(
            Function, include_inherited, lambda dobj: dobj.is_method,
            sort)

    def functions(self, include_inherited=True, sort=True) -&gt; List[&#39;Function&#39;]:
        &#34;&#34;&#34;
        Returns an optionally-sorted list of `pdoc.Function` objects that
        represent this class&#39; static functions.
        &#34;&#34;&#34;
        return self._filter_doc_objs(
            Function, include_inherited, lambda dobj: not dobj.is_method,
            sort)

    def inherited_members(self) -&gt; List[Tuple[&#39;Class&#39;, List[Doc]]]:
        &#34;&#34;&#34;
        Returns all inherited members as a list of tuples
        (ancestor class, list of ancestor class&#39; members sorted by name),
        sorted by MRO.
        &#34;&#34;&#34;
        return sorted(((cast(Class, k), sorted(g))
                       for k, g in groupby((i.inherits
                                            for i in self.doc.values() if i.inherits),
                                           key=lambda i: i.cls)),                   # type: ignore
                      key=lambda x, _mro_index=self.mro().index: _mro_index(x[0]))  # type: ignore

    def _fill_inheritance(self):
        &#34;&#34;&#34;
        Traverses this class&#39;s ancestor list and attempts to fill in
        missing documentation objects from its ancestors.

        Afterwards, call to `pdoc.Class._link_inheritance()` to also
        set `pdoc.Doc.inherits` pointers.
        &#34;&#34;&#34;
        super_members = self._super_members = {}
        for cls in self.mro(only_documented=True):
            for name, dobj in cls.doc.items():
                if name not in super_members and dobj.docstring:
                    super_members[name] = dobj
                    if name not in self.doc:
                        dobj = copy(dobj)
                        dobj.cls = self

                        self.doc[name] = dobj
                        self.module._context[dobj.refname] = dobj

    def _link_inheritance(self):
        &#34;&#34;&#34;
        Set `pdoc.Doc.inherits` pointers to inherited ancestors&#39; members,
        as appropriate. This must be called after
        `pdoc.Class._fill_inheritance()`.

        The reason this is split in two parts is that in-between
        the `__pdoc__` overrides are applied.
        &#34;&#34;&#34;
        if not hasattr(self, &#39;_super_members&#39;):
            return

        for name, parent_dobj in self._super_members.items():
            try:
                dobj = self.doc[name]
            except KeyError:
                # There is a key in some __pdoc__ dict blocking this member
                continue
            if (dobj.obj is parent_dobj.obj or
                    (dobj.docstring or parent_dobj.docstring) == parent_dobj.docstring):
                dobj.inherits = parent_dobj
                dobj.docstring = parent_dobj.docstring
        del self._super_members</code></pre>
</details>
<div class="desc"><p>Representation of a class' documentation.</p>
<p>Initializes a documentation object, where <code>name</code> is the public
identifier name, <code>module</code> is a <code><a title="pdoc.Module" href="#pdoc.Module">Module</a></code> object where raw
Python object <code>obj</code> is defined, and <code>docstring</code> is its
documentation string. If <code>docstring</code> is left empty, it will be
read with <code>inspect.getdoc()</code>.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pdoc.Doc" href="#pdoc.Doc">Doc</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pdoc.Class.doc"><code class="name">var <span class="ident">doc</span></code></dt>
<dd>
<div class="desc"><p>A mapping from identifier name to a <code><a title="pdoc.Doc" href="#pdoc.Doc">Doc</a></code> objects.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pdoc.Class.class_variables"><code class="name flex">
<span>def <span class="ident">class_variables</span></span>(<span>self, include_inherited=True, sort=True) â€‘>Â List[<a title="pdoc.Variable" href="#pdoc.Variable">Variable</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdoc3/pdoc/blob/5570f9a425d7cac7f7071c4c4d17a9edae20dc3d/pdoc/__init__.py#L1188-L1195" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def class_variables(self, include_inherited=True, sort=True) -&gt; List[&#39;Variable&#39;]:
    &#34;&#34;&#34;
    Returns an optionally-sorted list of `pdoc.Variable` objects that
    represent this class&#39; class variables.
    &#34;&#34;&#34;
    return self._filter_doc_objs(
        Variable, include_inherited, lambda dobj: not dobj.instance_var,
        sort)</code></pre>
</details>
<div class="desc"><p>Returns an optionally-sorted list of <code><a title="pdoc.Variable" href="#pdoc.Variable">Variable</a></code> objects that
represent this class' class variables.</p></div>
</dd>
<dt id="pdoc.Class.functions"><code class="name flex">
<span>def <span class="ident">functions</span></span>(<span>self, include_inherited=True, sort=True) â€‘>Â List[<a title="pdoc.Function" href="#pdoc.Function">Function</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdoc3/pdoc/blob/5570f9a425d7cac7f7071c4c4d17a9edae20dc3d/pdoc/__init__.py#L1216-L1223" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def functions(self, include_inherited=True, sort=True) -&gt; List[&#39;Function&#39;]:
    &#34;&#34;&#34;
    Returns an optionally-sorted list of `pdoc.Function` objects that
    represent this class&#39; static functions.
    &#34;&#34;&#34;
    return self._filter_doc_objs(
        Function, include_inherited, lambda dobj: not dobj.is_method,
        sort)</code></pre>
</details>
<div class="desc"><p>Returns an optionally-sorted list of <code><a title="pdoc.Function" href="#pdoc.Function">Function</a></code> objects that
represent this class' static functions.</p></div>
</dd>
<dt id="pdoc.Class.inherited_members"><code class="name flex">
<span>def <span class="ident">inherited_members</span></span>(<span>self) â€‘>Â List[Tuple[<a title="pdoc.Class" href="#pdoc.Class">Class</a>,Â List[<a title="pdoc.Doc" href="#pdoc.Doc">Doc</a>]]]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdoc3/pdoc/blob/5570f9a425d7cac7f7071c4c4d17a9edae20dc3d/pdoc/__init__.py#L1225-L1235" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def inherited_members(self) -&gt; List[Tuple[&#39;Class&#39;, List[Doc]]]:
    &#34;&#34;&#34;
    Returns all inherited members as a list of tuples
    (ancestor class, list of ancestor class&#39; members sorted by name),
    sorted by MRO.
    &#34;&#34;&#34;
    return sorted(((cast(Class, k), sorted(g))
                   for k, g in groupby((i.inherits
                                        for i in self.doc.values() if i.inherits),
                                       key=lambda i: i.cls)),                   # type: ignore
                  key=lambda x, _mro_index=self.mro().index: _mro_index(x[0]))  # type: ignore</code></pre>
</details>
<div class="desc"><p>Returns all inherited members as a list of tuples
(ancestor class, list of ancestor class' members sorted by name),
sorted by MRO.</p></div>
</dd>
<dt id="pdoc.Class.instance_variables"><code class="name flex">
<span>def <span class="ident">instance_variables</span></span>(<span>self, include_inherited=True, sort=True) â€‘>Â List[<a title="pdoc.Variable" href="#pdoc.Variable">Variable</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdoc3/pdoc/blob/5570f9a425d7cac7f7071c4c4d17a9edae20dc3d/pdoc/__init__.py#L1197-L1205" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def instance_variables(self, include_inherited=True, sort=True) -&gt; List[&#39;Variable&#39;]:
    &#34;&#34;&#34;
    Returns an optionally-sorted list of `pdoc.Variable` objects that
    represent this class&#39; instance variables. Instance variables
    are those defined in a class&#39;s `__init__` as `self.variable = ...`.
    &#34;&#34;&#34;
    return self._filter_doc_objs(
        Variable, include_inherited, lambda dobj: dobj.instance_var,
        sort)</code></pre>
</details>
<div class="desc"><p>Returns an optionally-sorted list of <code><a title="pdoc.Variable" href="#pdoc.Variable">Variable</a></code> objects that
represent this class' instance variables. Instance variables
are those defined in a class's <code>__init__</code> as <code>self.variable = ...</code>.</p></div>
</dd>
<dt id="pdoc.Class.methods"><code class="name flex">
<span>def <span class="ident">methods</span></span>(<span>self, include_inherited=True, sort=True) â€‘>Â List[<a title="pdoc.Function" href="#pdoc.Function">Function</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdoc3/pdoc/blob/5570f9a425d7cac7f7071c4c4d17a9edae20dc3d/pdoc/__init__.py#L1207-L1214" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def methods(self, include_inherited=True, sort=True) -&gt; List[&#39;Function&#39;]:
    &#34;&#34;&#34;
    Returns an optionally-sorted list of `pdoc.Function` objects that
    represent this class&#39; methods.
    &#34;&#34;&#34;
    return self._filter_doc_objs(
        Function, include_inherited, lambda dobj: dobj.is_method,
        sort)</code></pre>
</details>
<div class="desc"><p>Returns an optionally-sorted list of <code><a title="pdoc.Function" href="#pdoc.Function">Function</a></code> objects that
represent this class' methods.</p></div>
</dd>
<dt id="pdoc.Class.mro"><code class="name flex">
<span>def <span class="ident">mro</span></span>(<span>self, only_documented=False) â€‘>Â List[<a title="pdoc.Class" href="#pdoc.Class">Class</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdoc3/pdoc/blob/5570f9a425d7cac7f7071c4c4d17a9edae20dc3d/pdoc/__init__.py#L1133-L1154" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def mro(self, only_documented=False) -&gt; List[&#39;Class&#39;]:
    &#34;&#34;&#34;
    Returns a list of ancestor (superclass) documentation objects
    in method resolution order.

    The list will contain objects of type `pdoc.Class`
    if the types are documented, and `pdoc.External` otherwise.
    &#34;&#34;&#34;
    classes = [cast(Class, self.module.find_class(c))
               for c in inspect.getmro(self.obj)
               if c not in (self.obj, object)]
    if self in classes:
        # This can contain self in case of a class inheriting from
        # a class with (previously) the same name. E.g.
        #
        #     class Loc(namedtuple(&#39;Loc&#39;, &#39;lat lon&#39;)): ...
        #
        # We remove it from ancestors so that toposort doesn&#39;t break.
        classes.remove(self)
    if only_documented:
        classes = _filter_type(Class, classes)
    return classes</code></pre>
</details>
<div class="desc"><p>Returns a list of ancestor (superclass) documentation objects
in method resolution order.</p>
<p>The list will contain objects of type <code><a title="pdoc.Class" href="#pdoc.Class">Class</a></code>
if the types are documented, and <code><a title="pdoc.External" href="#pdoc.External">External</a></code> otherwise.</p></div>
</dd>
<dt id="pdoc.Class.params"><code class="name flex">
<span>def <span class="ident">params</span></span>(<span>self, *, annotate=False, link=None) â€‘>Â List[str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdoc3/pdoc/blob/5570f9a425d7cac7f7071c4c4d17a9edae20dc3d/pdoc/__init__.py#L1167-L1179" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def params(self, *, annotate=False, link=None) -&gt; List[str]:
    &#34;&#34;&#34;
    Return a list of formatted parameters accepted by the
    class constructor (method `__init__`). See `pdoc.Function.params`.
    &#34;&#34;&#34;
    name = self.name + &#39;.__init__&#39;
    qualname = self.qualname + &#39;.__init__&#39;
    refname = self.refname + &#39;.__init__&#39;
    exclusions = self.module.__pdoc__
    if name in exclusions or qualname in exclusions or refname in exclusions:
        return []

    return Function._params(self, annotate=annotate, link=link, module=self.module)</code></pre>
</details>
<div class="desc"><p>Return a list of formatted parameters accepted by the
class constructor (method <code>__init__</code>). See <code><a title="pdoc.Function.params" href="#pdoc.Function.params">Function.params()</a></code>.</p></div>
</dd>
<dt id="pdoc.Class.subclasses"><code class="name flex">
<span>def <span class="ident">subclasses</span></span>(<span>self) â€‘>Â List[<a title="pdoc.Class" href="#pdoc.Class">Class</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdoc3/pdoc/blob/5570f9a425d7cac7f7071c4c4d17a9edae20dc3d/pdoc/__init__.py#L1156-L1165" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def subclasses(self) -&gt; List[&#39;Class&#39;]:
    &#34;&#34;&#34;
    Returns a list of subclasses of this class that are visible to the
    Python interpreter (obtained from `type.__subclasses__()`).

    The objects in the list are of type `pdoc.Class` if available,
    and `pdoc.External` otherwise.
    &#34;&#34;&#34;
    return sorted(cast(Class, self.module.find_class(c))
                  for c in type.__subclasses__(self.obj))</code></pre>
</details>
<div class="desc"><p>Returns a list of subclasses of this class that are visible to the
Python interpreter (obtained from <code>type.__subclasses__()</code>).</p>
<p>The objects in the list are of type <code><a title="pdoc.Class" href="#pdoc.Class">Class</a></code> if available,
and <code><a title="pdoc.External" href="#pdoc.External">External</a></code> otherwise.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pdoc.Doc" href="#pdoc.Doc">Doc</a></b></code>:
<ul class="hlist">
<li><code><a title="pdoc.Doc.docstring" href="#pdoc.Doc.docstring">docstring</a></code></li>
<li><code><a title="pdoc.Doc.inherits" href="#pdoc.Doc.inherits">inherits</a></code></li>
<li><code><a title="pdoc.Doc.module" href="#pdoc.Doc.module">module</a></code></li>
<li><code><a title="pdoc.Doc.name" href="#pdoc.Doc.name">name</a></code></li>
<li><code><a title="pdoc.Doc.obj" href="#pdoc.Doc.obj">obj</a></code></li>
<li><code><a title="pdoc.Doc.qualname" href="#pdoc.Doc.qualname">qualname</a></code></li>
<li><code><a title="pdoc.Doc.refname" href="#pdoc.Doc.refname">refname</a></code></li>
<li><code><a title="pdoc.Doc.source" href="#pdoc.Doc.source">source</a></code></li>
<li><code><a title="pdoc.Doc.url" href="#pdoc.Doc.url">url</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pdoc.Context"><code class="flex name class">
<span>class <span class="ident">Context</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdoc3/pdoc/blob/5570f9a425d7cac7f7071c4c4d17a9edae20dc3d/pdoc/__init__.py#L71-L90" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class Context(dict):
    &#34;&#34;&#34;
    The context object that maps all documented identifiers
    (`pdoc.Doc.refname`) to their respective `pdoc.Doc` objects.

    You can pass an instance of `pdoc.Context` to `pdoc.Module` constructor.
    All `pdoc.Module` objects that share the same `pdoc.Context` will see
    (and be able to link in HTML to) each other&#39;s identifiers.

    If you don&#39;t pass your own `Context` instance to `Module` constructor,
    a global context object will be used.
    &#34;&#34;&#34;
    __pdoc__[&#39;Context.__init__&#39;] = False

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        # A surrogate so that the check in Module._link_inheritance()
        # &#34;__pdoc__-overriden key {!r} does not exist&#34; can see the object
        # (and not warn).
        self.blacklisted = getattr(args[0], &#39;blacklisted&#39;, set()) if args else set()</code></pre>
</details>
<div class="desc"><p>The context object that maps all documented identifiers
(<code><a title="pdoc.Doc.refname" href="#pdoc.Doc.refname">Doc.refname</a></code>) to their respective <code><a title="pdoc.Doc" href="#pdoc.Doc">Doc</a></code> objects.</p>
<p>You can pass an instance of <code><a title="pdoc.Context" href="#pdoc.Context">Context</a></code> to <code><a title="pdoc.Module" href="#pdoc.Module">Module</a></code> constructor.
All <code><a title="pdoc.Module" href="#pdoc.Module">Module</a></code> objects that share the same <code><a title="pdoc.Context" href="#pdoc.Context">Context</a></code> will see
(and be able to link in HTML to) each other's identifiers.</p>
<p>If you don't pass your own <code><a title="pdoc.Context" href="#pdoc.Context">Context</a></code> instance to <code><a title="pdoc.Module" href="#pdoc.Module">Module</a></code> constructor,
a global context object will be used.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.dict</li>
</ul>
</dd>
<dt id="pdoc.Doc"><code class="flex name class">
<span>class <span class="ident">Doc</span></span>
<span>(</span><span>name:Â str, module, obj, docstring:Â strÂ =Â '')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdoc3/pdoc/blob/5570f9a425d7cac7f7071c4c4d17a9edae20dc3d/pdoc/__init__.py#L505-L640" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class Doc:
    &#34;&#34;&#34;
    A base class for all documentation objects.

    A documentation object corresponds to *something* in a Python module
    that has a docstring associated with it. Typically, this includes
    modules, classes, functions, and methods. However, `pdoc` adds support
    for extracting some docstrings from abstract syntax trees, making
    (module, class or instance) variables supported too.

    A special type of documentation object `pdoc.External` is used to
    represent identifiers that are not part of the public interface of
    a module. (The name &#34;External&#34; is a bit of a misnomer, since it can
    also correspond to unexported members of the module, particularly in
    a class&#39;s ancestor list.)
    &#34;&#34;&#34;

    def __init__(self, name: str, module, obj, docstring: str = &#39;&#39;):
        &#34;&#34;&#34;
        Initializes a documentation object, where `name` is the public
        identifier name, `module` is a `pdoc.Module` object where raw
        Python object `obj` is defined, and `docstring` is its
        documentation string. If `docstring` is left empty, it will be
        read with `inspect.getdoc()`.
        &#34;&#34;&#34;
        self.module = module
        &#34;&#34;&#34;
        The module documentation object that this object is defined in.
        &#34;&#34;&#34;

        self.name = name
        &#34;&#34;&#34;
        The identifier name for this object.
        &#34;&#34;&#34;

        self.obj = obj
        &#34;&#34;&#34;
        The raw python object.
        &#34;&#34;&#34;

        docstring = (docstring or inspect.getdoc(obj) or &#39;&#39;).strip()
        if &#39;.. include::&#39; in docstring:
            from pdoc.html_helpers import _ToMarkdown
            docstring = _ToMarkdown.admonitions(docstring, self.module, (&#39;include&#39;,))
        self.docstring = docstring
        &#34;&#34;&#34;
        The cleaned docstring for this object with any `.. include::`
        directives resolved (i.e. content included).
        &#34;&#34;&#34;

        self.inherits: Optional[Union[Class, Function, Variable]] = None
        &#34;&#34;&#34;
        The Doc object (Class, Function, or Variable) this object inherits from,
        if any.
        &#34;&#34;&#34;

    def __repr__(self):
        return f&#39;&lt;{self.__class__.__name__} {self.refname!r}&gt;&#39;

    @property
    @lru_cache()
    def source(self) -&gt; str:
        &#34;&#34;&#34;
        Cleaned (dedented) source code of the Python object. If not
        available, an empty string.
        &#34;&#34;&#34;
        try:
            lines, _ = inspect.getsourcelines(_unwrap_descriptor(self))
        except (ValueError, TypeError, OSError):
            return &#39;&#39;
        return inspect.cleandoc(&#39;&#39;.join([&#39;\n&#39;] + lines))

    @property
    def refname(self) -&gt; str:
        &#34;&#34;&#34;
        Reference name of this documentation
        object, usually its fully qualified path
        (e.g. &lt;code&gt;pdoc.Doc.refname&lt;/code&gt;). Every
        documentation object provides this property.
        &#34;&#34;&#34;
        # Ok for Module and External, the rest need it overriden
        return self.name

    @property
    def qualname(self) -&gt; str:
        &#34;&#34;&#34;
        Module-relative &#34;qualified&#34; name of this documentation
        object, used for show (e.g. &lt;code&gt;Doc.qualname&lt;/code&gt;).
        &#34;&#34;&#34;
        return getattr(self.obj, &#39;__qualname__&#39;, self.name)

    @lru_cache()
    def url(self, relative_to: Optional[&#39;Module&#39;] = None, *, link_prefix: str = &#39;&#39;,
            top_ancestor: bool = False) -&gt; str:
        &#34;&#34;&#34;
        Canonical relative URL (including page fragment) for this
        documentation object.

        Specify `relative_to` (a `pdoc.Module` object) to obtain a
        relative URL.

        For usage of `link_prefix` see `pdoc.html()`.

        If `top_ancestor` is `True`, the returned URL instead points to
        the top ancestor in the object&#39;s `pdoc.Doc.inherits` chain.
        &#34;&#34;&#34;
        if top_ancestor:
            self = self._inherits_top()

        if relative_to is None or link_prefix:
            return link_prefix + self._url()

        if self.module.name == relative_to.name:
            return f&#39;#{self.refname}&#39;

        # Otherwise, compute relative path from current module to link target
        url = os.path.relpath(self._url(), relative_to.url()).replace(path.sep, &#39;/&#39;)
        # We have one set of &#39;..&#39; too many
        if url.startswith(&#39;../&#39;):
            url = url[3:]
        return url

    def _url(self):
        return f&#39;{self.module._url()}#{self.refname}&#39;

    def _inherits_top(self):
        &#34;&#34;&#34;
        Follow the `pdoc.Doc.inherits` chain and return the top object.
        &#34;&#34;&#34;
        top = self
        while top.inherits:
            top = top.inherits
        return top

    def __lt__(self, other):
        return self.refname &lt; other.refname</code></pre>
</details>
<div class="desc"><p>A base class for all documentation objects.</p>
<p>A documentation object corresponds to <em>something</em> in a Python module
that has a docstring associated with it. Typically, this includes
modules, classes, functions, and methods. However, <code><a title="pdoc" href="#pdoc">pdoc</a></code> adds support
for extracting some docstrings from abstract syntax trees, making
(module, class or instance) variables supported too.</p>
<p>A special type of documentation object <code><a title="pdoc.External" href="#pdoc.External">External</a></code> is used to
represent identifiers that are not part of the public interface of
a module. (The name "External" is a bit of a misnomer, since it can
also correspond to unexported members of the module, particularly in
a class's ancestor list.)</p>
<p>Initializes a documentation object, where <code>name</code> is the public
identifier name, <code>module</code> is a <code><a title="pdoc.Module" href="#pdoc.Module">Module</a></code> object where raw
Python object <code>obj</code> is defined, and <code>docstring</code> is its
documentation string. If <code>docstring</code> is left empty, it will be
read with <code>inspect.getdoc()</code>.</p></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pdoc.Class" href="#pdoc.Class">Class</a></li>
<li><a title="pdoc.External" href="#pdoc.External">External</a></li>
<li><a title="pdoc.Function" href="#pdoc.Function">Function</a></li>
<li><a title="pdoc.Module" href="#pdoc.Module">Module</a></li>
<li><a title="pdoc.Variable" href="#pdoc.Variable">Variable</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pdoc.Doc.docstring"><code class="name">var <span class="ident">docstring</span></code></dt>
<dd>
<div class="desc"><p>The cleaned docstring for this object with any <code>.. include::</code>
directives resolved (i.e. content included).</p></div>
</dd>
<dt id="pdoc.Doc.inherits"><code class="name">var <span class="ident">inherits</span></code></dt>
<dd>
<div class="desc"><p>The Doc object (Class, Function, or Variable) this object inherits from,
if any.</p></div>
</dd>
<dt id="pdoc.Doc.module"><code class="name">var <span class="ident">module</span></code></dt>
<dd>
<div class="desc"><p>The module documentation object that this object is defined in.</p></div>
</dd>
<dt id="pdoc.Doc.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>The identifier name for this object.</p></div>
</dd>
<dt id="pdoc.Doc.obj"><code class="name">var <span class="ident">obj</span></code></dt>
<dd>
<div class="desc"><p>The raw python object.</p></div>
</dd>
<dt id="pdoc.Doc.qualname"><code class="name">prop <span class="ident">qualname</span> :Â str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdoc3/pdoc/blob/5570f9a425d7cac7f7071c4c4d17a9edae20dc3d/pdoc/__init__.py#L588-L594" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@property
def qualname(self) -&gt; str:
    &#34;&#34;&#34;
    Module-relative &#34;qualified&#34; name of this documentation
    object, used for show (e.g. &lt;code&gt;Doc.qualname&lt;/code&gt;).
    &#34;&#34;&#34;
    return getattr(self.obj, &#39;__qualname__&#39;, self.name)</code></pre>
</details>
<div class="desc"><p>Module-relative "qualified" name of this documentation
object, used for show (e.g. <code>Doc.qualname</code>).</p></div>
</dd>
<dt id="pdoc.Doc.refname"><code class="name">prop <span class="ident">refname</span> :Â str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdoc3/pdoc/blob/5570f9a425d7cac7f7071c4c4d17a9edae20dc3d/pdoc/__init__.py#L577-L586" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@property
def refname(self) -&gt; str:
    &#34;&#34;&#34;
    Reference name of this documentation
    object, usually its fully qualified path
    (e.g. &lt;code&gt;pdoc.Doc.refname&lt;/code&gt;). Every
    documentation object provides this property.
    &#34;&#34;&#34;
    # Ok for Module and External, the rest need it overriden
    return self.name</code></pre>
</details>
<div class="desc"><p>Reference name of this documentation
object, usually its fully qualified path
(e.g. <code>pdoc.Doc.refname</code>). Every
documentation object provides this property.</p></div>
</dd>
<dt id="pdoc.Doc.source"><code class="name">prop <span class="ident">source</span> :Â str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdoc3/pdoc/blob/5570f9a425d7cac7f7071c4c4d17a9edae20dc3d/pdoc/__init__.py#L564-L575" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@property
@lru_cache()
def source(self) -&gt; str:
    &#34;&#34;&#34;
    Cleaned (dedented) source code of the Python object. If not
    available, an empty string.
    &#34;&#34;&#34;
    try:
        lines, _ = inspect.getsourcelines(_unwrap_descriptor(self))
    except (ValueError, TypeError, OSError):
        return &#39;&#39;
    return inspect.cleandoc(&#39;&#39;.join([&#39;\n&#39;] + lines))</code></pre>
</details>
<div class="desc"><p>Cleaned (dedented) source code of the Python object. If not
available, an empty string.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pdoc.Doc.url"><code class="name flex">
<span>def <span class="ident">url</span></span>(<span>self,<br>relative_to:Â ForwardRef('<a title="pdoc.Module" href="#pdoc.Module">Module</a>')Â |Â NoneÂ =Â None,<br>*,<br>link_prefix:Â strÂ =Â '',<br>top_ancestor:Â boolÂ =Â False) â€‘>Â str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdoc3/pdoc/blob/5570f9a425d7cac7f7071c4c4d17a9edae20dc3d/pdoc/__init__.py#L596-L625" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@lru_cache()
def url(self, relative_to: Optional[&#39;Module&#39;] = None, *, link_prefix: str = &#39;&#39;,
        top_ancestor: bool = False) -&gt; str:
    &#34;&#34;&#34;
    Canonical relative URL (including page fragment) for this
    documentation object.

    Specify `relative_to` (a `pdoc.Module` object) to obtain a
    relative URL.

    For usage of `link_prefix` see `pdoc.html()`.

    If `top_ancestor` is `True`, the returned URL instead points to
    the top ancestor in the object&#39;s `pdoc.Doc.inherits` chain.
    &#34;&#34;&#34;
    if top_ancestor:
        self = self._inherits_top()

    if relative_to is None or link_prefix:
        return link_prefix + self._url()

    if self.module.name == relative_to.name:
        return f&#39;#{self.refname}&#39;

    # Otherwise, compute relative path from current module to link target
    url = os.path.relpath(self._url(), relative_to.url()).replace(path.sep, &#39;/&#39;)
    # We have one set of &#39;..&#39; too many
    if url.startswith(&#39;../&#39;):
        url = url[3:]
    return url</code></pre>
</details>
<div class="desc"><p>Canonical relative URL (including page fragment) for this
documentation object.</p>
<p>Specify <code>relative_to</code> (a <code><a title="pdoc.Module" href="#pdoc.Module">Module</a></code> object) to obtain a
relative URL.</p>
<p>For usage of <code>link_prefix</code> see <code><a title="pdoc.html" href="#pdoc.html">html()</a></code>.</p>
<p>If <code>top_ancestor</code> is <code>True</code>, the returned URL instead points to
the top ancestor in the object's <code><a title="pdoc.Doc.inherits" href="#pdoc.Doc.inherits">Doc.inherits</a></code> chain.</p></div>
</dd>
</dl>
</dd>
<dt id="pdoc.External"><code class="flex name class">
<span>class <span class="ident">External</span></span>
<span>(</span><span>name:Â str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdoc3/pdoc/blob/5570f9a425d7cac7f7071c4c4d17a9edae20dc3d/pdoc/__init__.py#L1688-L1723" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class External(Doc):
    &#34;&#34;&#34;
    A representation of an external identifier. The textual
    representation is the same as an internal identifier.

    External identifiers are also used to represent something that is
    not documented but appears somewhere in the public interface (like
    the ancestor list of a class).
    &#34;&#34;&#34;

    __pdoc__[&#34;External.docstring&#34;] = &#34;&#34;&#34;
        An empty string. External identifiers do not have
        docstrings.
        &#34;&#34;&#34;
    __pdoc__[&#34;External.module&#34;] = &#34;&#34;&#34;
        Always `None`. External identifiers have no associated
        `pdoc.Module`.
        &#34;&#34;&#34;
    __pdoc__[&#34;External.name&#34;] = &#34;&#34;&#34;
        Always equivalent to `pdoc.External.refname` since external
        identifiers are always expressed in their fully qualified
        form.
        &#34;&#34;&#34;

    def __init__(self, name: str):
        &#34;&#34;&#34;
        Initializes an external identifier with `name`, where `name`
        should be a fully qualified name.
        &#34;&#34;&#34;
        super().__init__(name, None, None)

    def url(self, *args, **kwargs):
        &#34;&#34;&#34;
        `External` objects return absolute urls matching `/{name}.ext`.
        &#34;&#34;&#34;
        return f&#39;/{self.name}.ext&#39;</code></pre>
</details>
<div class="desc"><p>A representation of an external identifier. The textual
representation is the same as an internal identifier.</p>
<p>External identifiers are also used to represent something that is
not documented but appears somewhere in the public interface (like
the ancestor list of a class).</p>
<p>Initializes an external identifier with <code>name</code>, where <code>name</code>
should be a fully qualified name.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pdoc.Doc" href="#pdoc.Doc">Doc</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pdoc.External.url"><code class="name flex">
<span>def <span class="ident">url</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdoc3/pdoc/blob/5570f9a425d7cac7f7071c4c4d17a9edae20dc3d/pdoc/__init__.py#L1719-L1723" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def url(self, *args, **kwargs):
    &#34;&#34;&#34;
    `External` objects return absolute urls matching `/{name}.ext`.
    &#34;&#34;&#34;
    return f&#39;/{self.name}.ext&#39;</code></pre>
</details>
<div class="desc"><p><code><a title="pdoc.External" href="#pdoc.External">External</a></code> objects return absolute urls matching <code>/{name}.ext</code>.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pdoc.Doc" href="#pdoc.Doc">Doc</a></b></code>:
<ul class="hlist">
<li><code><a title="pdoc.Doc.docstring" href="#pdoc.Doc.docstring">docstring</a></code></li>
<li><code><a title="pdoc.Doc.inherits" href="#pdoc.Doc.inherits">inherits</a></code></li>
<li><code><a title="pdoc.Doc.module" href="#pdoc.Doc.module">module</a></code></li>
<li><code><a title="pdoc.Doc.name" href="#pdoc.Doc.name">name</a></code></li>
<li><code><a title="pdoc.Doc.obj" href="#pdoc.Doc.obj">obj</a></code></li>
<li><code><a title="pdoc.Doc.qualname" href="#pdoc.Doc.qualname">qualname</a></code></li>
<li><code><a title="pdoc.Doc.refname" href="#pdoc.Doc.refname">refname</a></code></li>
<li><code><a title="pdoc.Doc.source" href="#pdoc.Doc.source">source</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pdoc.Function"><code class="flex name class">
<span>class <span class="ident">Function</span></span>
<span>(</span><span>name:Â str,<br>module:Â <a title="pdoc.Module" href="#pdoc.Module">Module</a>,<br>obj,<br>*,<br>cls:Â <a title="pdoc.Class" href="#pdoc.Class">Class</a>Â |Â NoneÂ =Â None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdoc3/pdoc/blob/5570f9a425d7cac7f7071c4c4d17a9edae20dc3d/pdoc/__init__.py#L1370-L1637" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class Function(Doc):
    &#34;&#34;&#34;
    Representation of documentation for a function or method.
    &#34;&#34;&#34;
    def __init__(self, name: str, module: Module, obj, *, cls: Optional[Class] = None):
        &#34;&#34;&#34;
        Same as `pdoc.Doc`, except `obj` must be a
        Python function object. The docstring is gathered automatically.

        `cls` should be set when this is a method or a static function
        beloing to a class. `cls` should be a `pdoc.Class` object.

        `method` should be `True` when the function is a method. In
        all other cases, it should be `False`.
        &#34;&#34;&#34;
        assert callable(obj), (name, module, obj)
        super().__init__(name, module, obj)

        self.cls = cls
        &#34;&#34;&#34;
        The `pdoc.Class` documentation object if the function is a method.
        If not, this is None.
        &#34;&#34;&#34;

    @property
    def is_method(self) -&gt; bool:
        &#34;&#34;&#34;
        Whether this function is a normal bound method.

        In particular, static and class methods have this set to False.
        &#34;&#34;&#34;
        assert self.cls
        return not Class._method_type(self.cls.obj, self.name)

    @property
    def method(self):
        warn(&#39;`Function.method` is deprecated. Use: `Function.is_method`&#39;, DeprecationWarning,
             stacklevel=2)
        return self.is_method

    __pdoc__[&#39;Function.method&#39;] = False

    def funcdef(self) -&gt; str:
        &#34;&#34;&#34;
        Generates the string of keywords used to define the function,
        for example `def` or `async def`.
        &#34;&#34;&#34;
        return &#39;async def&#39; if self._is_async else &#39;def&#39;

    @property
    def _is_async(self):
        &#34;&#34;&#34;
        Returns whether is function is asynchronous, either as a coroutine or an async
        generator.
        &#34;&#34;&#34;
        try:
            # Both of these are required because coroutines aren&#39;t classified as async
            # generators and vice versa.
            obj = inspect.unwrap(self.obj)
            return (inspect.iscoroutinefunction(obj) or
                    inspect.isasyncgenfunction(obj))
        except AttributeError:
            return False

    def return_annotation(self, *, link=None) -&gt; str:
        &#34;&#34;&#34;Formatted function return type annotation or empty string if none.&#34;&#34;&#34;
        annot = &#39;&#39;
        for method in (
                lambda: _get_type_hints(self.obj)[&#39;return&#39;],
                # Mainly for non-property variables
                lambda: _get_type_hints(cast(Class, self.cls).obj)[self.name],
                # global variables
                lambda: _get_type_hints(not self.cls and self.module.obj)[self.name],
                # properties
                lambda: inspect.signature(_unwrap_descriptor(self)).return_annotation,
                # Use raw annotation strings in unmatched forward declarations
                lambda: cast(Class, self.cls).obj.__annotations__[self.name],
                # Extract annotation from the docstring for C builtin function
                lambda: Function._signature_from_string(self).return_annotation,
        ):
            try:
                annot = method()
            except Exception:
                continue
            else:
                break
        else:
            # Don&#39;t warn on variables. The annotation just isn&#39;t available.
            if not isinstance(self, Variable):
                warn(f&#34;Error handling return annotation for {self!r}&#34;, stacklevel=3)

        if annot is inspect.Parameter.empty or not annot:
            return &#39;&#39;

        if isinstance(annot, str):
            s = annot
        else:
            s = _formatannotation(annot)
            s = re.sub(r&#39;\bForwardRef\((?P&lt;quot&gt;[\&#34;\&#39;])(?P&lt;str&gt;.*?)(?P=quot)\)&#39;,
                       r&#39;\g&lt;str&gt;&#39;, s)
        s = s.replace(&#39; &#39;, &#39;\N{NBSP}&#39;)  # Better line breaks in html signatures

        if link:
            from pdoc.html_helpers import _linkify
            s = re.sub(r&#39;[\w\.]+&#39;, partial(_linkify, link=link, module=self.module), s)
        return s

    def params(self, *, annotate: bool = False,
               link: Optional[Callable[[Doc], str]] = None) -&gt; List[str]:
        &#34;&#34;&#34;
        Returns a list where each element is a nicely formatted
        parameter of this function. This includes argument lists,
        keyword arguments and default values, and it doesn&#39;t include any
        optional arguments whose names begin with an underscore.

        If `annotate` is True, the parameter strings include [PEP 484]
        type hint annotations.

        [PEP 484]: https://www.python.org/dev/peps/pep-0484/
        &#34;&#34;&#34;
        return self._params(self, annotate=annotate, link=link, module=self.module)

    @staticmethod
    def _params(doc_obj, annotate=False, link=None, module=None):
        try:
            # We want __init__ to actually be implemented somewhere in the
            # MRO to still satisfy https://github.com/pdoc3/pdoc/issues/124
            if (
                inspect.isclass(doc_obj.obj)
                and doc_obj.obj.__init__ is not object.__init__
            ):
                # Remove the first argument (self) from __init__ signature
                init_sig = inspect.signature(doc_obj.obj.__init__)
                init_params = list(init_sig.parameters.values())
                signature = init_sig.replace(parameters=init_params[1:])
            else:
                signature = inspect.signature(doc_obj.obj)
        except ValueError:
            signature = Function._signature_from_string(doc_obj)
            if not signature:
                return [&#39;...&#39;]

        def safe_default_value(p: inspect.Parameter):
            value = p.default
            if value is inspect.Parameter.empty:
                return p

            replacement = next((i for i in (&#39;os.environ&#39;,
                                            &#39;sys.stdin&#39;,
                                            &#39;sys.stdout&#39;,
                                            &#39;sys.stderr&#39;,)
                                if value is eval(i)), None)
            if not replacement:
                if isinstance(value, enum.Enum):
                    replacement = str(value)
                elif inspect.isclass(value):
                    replacement = f&#39;{value.__module__ or _UNKNOWN_MODULE}.{value.__qualname__}&#39;
                elif &#39; at 0x&#39; in repr(value):
                    replacement = re.sub(r&#39; at 0x\w+&#39;, &#39;&#39;, repr(value))

                nonlocal link
                if link and (&#39;&lt;&#39; in repr(value) or &#39;&gt;&#39; in repr(value)):
                    import html
                    replacement = html.escape(replacement or repr(value))

            if replacement:
                class mock:
                    def __repr__(self):
                        return replacement
                return p.replace(default=mock())
            return p

        params = []
        kw_only = False
        pos_only = False
        EMPTY = inspect.Parameter.empty

        if link:
            from pdoc.html_helpers import _linkify
            _linkify = partial(_linkify, link=link, module=module)

        for p in signature.parameters.values():  # type: inspect.Parameter
            if not _is_public(p.name) and p.default is not EMPTY:
                continue

            if p.kind == p.POSITIONAL_ONLY:
                pos_only = True
            elif pos_only:
                params.append(&#34;/&#34;)
                pos_only = False

            if p.kind == p.VAR_POSITIONAL:
                kw_only = True
            if p.kind == p.KEYWORD_ONLY and not kw_only:
                kw_only = True
                params.append(&#39;*&#39;)

            p = safe_default_value(p)

            if not annotate:
                p = p.replace(annotation=EMPTY)

            formatted = p.name
            if p.annotation is not EMPTY:
                annotation = _formatannotation(p.annotation).replace(&#39; &#39;, &#39;\N{NBSP}&#39;)
                # &#34;Eval&#34; forward-declarations (typing string literals)
                if isinstance(p.annotation, str):
                    annotation = annotation.strip(&#34;&#39;&#34;)
                if link:
                    annotation = re.sub(r&#39;[\w\.]+&#39;, _linkify, annotation)
                formatted += f&#39;:\N{NBSP}{annotation}&#39;
            if p.default is not EMPTY:
                if p.annotation is not EMPTY:
                    formatted += f&#39;\N{NBSP}=\N{NBSP}{repr(p.default)}&#39;
                else:
                    formatted += f&#39;={repr(p.default)}&#39;
            if p.kind == p.VAR_POSITIONAL:
                formatted = f&#39;*{formatted}&#39;
            elif p.kind == p.VAR_KEYWORD:
                formatted = f&#39;**{formatted}&#39;

            params.append(formatted)

        if pos_only:
            params.append(&#34;/&#34;)

        return params

    @staticmethod
    @lru_cache()
    def _signature_from_string(self):
        signature = None
        for expr, cleanup_docstring, filter in (
                # Full proper typed signature, such as one from pybind11
                (r&#39;^{}\(.*\)(?: -&gt; .*)?$&#39;, True, lambda s: s),
                # Human-readable, usage-like signature from some Python builtins
                # (e.g. `range` or `slice` or `itertools.repeat` or `numpy.arange`)
                (r&#39;^{}\(.*\)(?= -|$)&#39;, False, lambda s: s.replace(&#39;[&#39;, &#39;&#39;).replace(&#39;]&#39;, &#39;&#39;)),
        ):
            strings = sorted(re.findall(expr.format(self.name),
                                        self.docstring, re.MULTILINE),
                             key=len, reverse=True)
            if strings:
                string = filter(strings[0])
                _locals, _globals = {}, {}
                _globals.update({&#39;capsule&#39;: None})  # pybind11 capsule data type
                _globals.update(typing.__dict__)
                _globals.update(self.module.obj.__dict__)
                # Trim binding module basename from type annotations
                # See: https://github.com/pdoc3/pdoc/pull/148#discussion_r407114141
                module_basename = self.module.name.rsplit(&#39;.&#39;, maxsplit=1)[-1]
                if module_basename in string and module_basename not in _globals:
                    string = re.sub(fr&#39;(?&lt;!\.)\b{module_basename}\.\b&#39;, &#39;&#39;, string)

                try:
                    exec(f&#39;def {string}: pass&#39;, _globals, _locals)
                except Exception:
                    continue
                signature = inspect.signature(_locals[self.name])
                if cleanup_docstring and len(strings) == 1:
                    # Remove signature from docstring variable
                    self.docstring = self.docstring.replace(strings[0], &#39;&#39;)
                break
        return signature

    @property
    def refname(self) -&gt; str:
        return f&#39;{self.cls.refname if self.cls else self.module.refname}.{self.name}&#39;</code></pre>
</details>
<div class="desc"><p>Representation of documentation for a function or method.</p>
<p>Same as <code><a title="pdoc.Doc" href="#pdoc.Doc">Doc</a></code>, except <code>obj</code> must be a
Python function object. The docstring is gathered automatically.</p>
<p><code>cls</code> should be set when this is a method or a static function
beloing to a class. <code>cls</code> should be a <code><a title="pdoc.Class" href="#pdoc.Class">Class</a></code> object.</p>
<p><code>method</code> should be <code>True</code> when the function is a method. In
all other cases, it should be <code>False</code>.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pdoc.Doc" href="#pdoc.Doc">Doc</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pdoc.Function.cls"><code class="name">var <span class="ident">cls</span></code></dt>
<dd>
<div class="desc"><p>The <code><a title="pdoc.Class" href="#pdoc.Class">Class</a></code> documentation object if the function is a method.
If not, this is None.</p></div>
</dd>
<dt id="pdoc.Function.is_method"><code class="name">prop <span class="ident">is_method</span> :Â bool</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdoc3/pdoc/blob/5570f9a425d7cac7f7071c4c4d17a9edae20dc3d/pdoc/__init__.py#L1394-L1402" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@property
def is_method(self) -&gt; bool:
    &#34;&#34;&#34;
    Whether this function is a normal bound method.

    In particular, static and class methods have this set to False.
    &#34;&#34;&#34;
    assert self.cls
    return not Class._method_type(self.cls.obj, self.name)</code></pre>
</details>
<div class="desc"><p>Whether this function is a normal bound method.</p>
<p>In particular, static and class methods have this set to False.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pdoc.Function.funcdef"><code class="name flex">
<span>def <span class="ident">funcdef</span></span>(<span>self) â€‘>Â str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdoc3/pdoc/blob/5570f9a425d7cac7f7071c4c4d17a9edae20dc3d/pdoc/__init__.py#L1412-L1417" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def funcdef(self) -&gt; str:
    &#34;&#34;&#34;
    Generates the string of keywords used to define the function,
    for example `def` or `async def`.
    &#34;&#34;&#34;
    return &#39;async def&#39; if self._is_async else &#39;def&#39;</code></pre>
</details>
<div class="desc"><p>Generates the string of keywords used to define the function,
for example <code>def</code> or <code>async def</code>.</p></div>
</dd>
<dt id="pdoc.Function.params"><code class="name flex">
<span>def <span class="ident">params</span></span>(<span>self,<br>*,<br>annotate:Â boolÂ =Â False,<br>link:Â Callable[[<a title="pdoc.Doc" href="#pdoc.Doc">Doc</a>],Â str]Â |Â NoneÂ =Â None) â€‘>Â List[str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdoc3/pdoc/blob/5570f9a425d7cac7f7071c4c4d17a9edae20dc3d/pdoc/__init__.py#L1477-L1490" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def params(self, *, annotate: bool = False,
           link: Optional[Callable[[Doc], str]] = None) -&gt; List[str]:
    &#34;&#34;&#34;
    Returns a list where each element is a nicely formatted
    parameter of this function. This includes argument lists,
    keyword arguments and default values, and it doesn&#39;t include any
    optional arguments whose names begin with an underscore.

    If `annotate` is True, the parameter strings include [PEP 484]
    type hint annotations.

    [PEP 484]: https://www.python.org/dev/peps/pep-0484/
    &#34;&#34;&#34;
    return self._params(self, annotate=annotate, link=link, module=self.module)</code></pre>
</details>
<div class="desc"><p>Returns a list where each element is a nicely formatted
parameter of this function. This includes argument lists,
keyword arguments and default values, and it doesn't include any
optional arguments whose names begin with an underscore.</p>
<p>If <code>annotate</code> is True, the parameter strings include <a href="https://www.python.org/dev/peps/pep-0484/">PEP 484</a>
type hint annotations.</p></div>
</dd>
<dt id="pdoc.Function.return_annotation"><code class="name flex">
<span>def <span class="ident">return_annotation</span></span>(<span>self, *, link=None) â€‘>Â str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdoc3/pdoc/blob/5570f9a425d7cac7f7071c4c4d17a9edae20dc3d/pdoc/__init__.py#L1434-L1475" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def return_annotation(self, *, link=None) -&gt; str:
    &#34;&#34;&#34;Formatted function return type annotation or empty string if none.&#34;&#34;&#34;
    annot = &#39;&#39;
    for method in (
            lambda: _get_type_hints(self.obj)[&#39;return&#39;],
            # Mainly for non-property variables
            lambda: _get_type_hints(cast(Class, self.cls).obj)[self.name],
            # global variables
            lambda: _get_type_hints(not self.cls and self.module.obj)[self.name],
            # properties
            lambda: inspect.signature(_unwrap_descriptor(self)).return_annotation,
            # Use raw annotation strings in unmatched forward declarations
            lambda: cast(Class, self.cls).obj.__annotations__[self.name],
            # Extract annotation from the docstring for C builtin function
            lambda: Function._signature_from_string(self).return_annotation,
    ):
        try:
            annot = method()
        except Exception:
            continue
        else:
            break
    else:
        # Don&#39;t warn on variables. The annotation just isn&#39;t available.
        if not isinstance(self, Variable):
            warn(f&#34;Error handling return annotation for {self!r}&#34;, stacklevel=3)

    if annot is inspect.Parameter.empty or not annot:
        return &#39;&#39;

    if isinstance(annot, str):
        s = annot
    else:
        s = _formatannotation(annot)
        s = re.sub(r&#39;\bForwardRef\((?P&lt;quot&gt;[\&#34;\&#39;])(?P&lt;str&gt;.*?)(?P=quot)\)&#39;,
                   r&#39;\g&lt;str&gt;&#39;, s)
    s = s.replace(&#39; &#39;, &#39;\N{NBSP}&#39;)  # Better line breaks in html signatures

    if link:
        from pdoc.html_helpers import _linkify
        s = re.sub(r&#39;[\w\.]+&#39;, partial(_linkify, link=link, module=self.module), s)
    return s</code></pre>
</details>
<div class="desc"><p>Formatted function return type annotation or empty string if none.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pdoc.Doc" href="#pdoc.Doc">Doc</a></b></code>:
<ul class="hlist">
<li><code><a title="pdoc.Doc.docstring" href="#pdoc.Doc.docstring">docstring</a></code></li>
<li><code><a title="pdoc.Doc.inherits" href="#pdoc.Doc.inherits">inherits</a></code></li>
<li><code><a title="pdoc.Doc.module" href="#pdoc.Doc.module">module</a></code></li>
<li><code><a title="pdoc.Doc.name" href="#pdoc.Doc.name">name</a></code></li>
<li><code><a title="pdoc.Doc.obj" href="#pdoc.Doc.obj">obj</a></code></li>
<li><code><a title="pdoc.Doc.qualname" href="#pdoc.Doc.qualname">qualname</a></code></li>
<li><code><a title="pdoc.Doc.refname" href="#pdoc.Doc.refname">refname</a></code></li>
<li><code><a title="pdoc.Doc.source" href="#pdoc.Doc.source">source</a></code></li>
<li><code><a title="pdoc.Doc.url" href="#pdoc.Doc.url">url</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pdoc.Module"><code class="flex name class">
<span>class <span class="ident">Module</span></span>
<span>(</span><span>module:Â strÂ |Â module,<br>*,<br>docfilter:Â Callable[[<a title="pdoc.Doc" href="#pdoc.Doc">Doc</a>],Â bool]Â |Â NoneÂ =Â None,<br>supermodule:Â ForwardRef('<a title="pdoc.Module" href="#pdoc.Module">Module</a>')Â |Â NoneÂ =Â None,<br>context:Â <a title="pdoc.Context" href="#pdoc.Context">Context</a>Â |Â NoneÂ =Â None,<br>skip_errors:Â boolÂ =Â False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdoc3/pdoc/blob/5570f9a425d7cac7f7071c4c4d17a9edae20dc3d/pdoc/__init__.py#L643-L1000" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class Module(Doc):
    &#34;&#34;&#34;
    Representation of a module&#39;s documentation.
    &#34;&#34;&#34;
    __pdoc__[&#34;Module.name&#34;] = &#34;&#34;&#34;
        The name of this module with respect to the context/path in which
        it was imported from. It is always an absolute import path.
        &#34;&#34;&#34;

    def __init__(self, module: Union[ModuleType, str], *,
                 docfilter: Optional[Callable[[Doc], bool]] = None,
                 supermodule: Optional[&#39;Module&#39;] = None,
                 context: Optional[Context] = None,
                 skip_errors: bool = False):
        &#34;&#34;&#34;
        Creates a `Module` documentation object given the actual
        module Python object.

        `docfilter` is an optional predicate that controls which
        sub-objects are documentated (see also: `pdoc.html()`).

        `supermodule` is the parent `pdoc.Module` this module is
        a submodule of.

        `context` is an instance of `pdoc.Context`. If `None` a
        global context object will be used.

        If `skip_errors` is `True` and an unimportable, erroneous
        submodule is encountered, a warning will be issued instead
        of raising an exception.
        &#34;&#34;&#34;
        if isinstance(module, str):
            module = import_module(module, skip_errors=skip_errors)

        super().__init__(module.__name__, self, module)
        if self.name.endswith(&#39;.__init__&#39;) and not self.is_package:
            self.name = self.name[:-len(&#39;.__init__&#39;)]

        self._context = _global_context if context is None else context
        &#34;&#34;&#34;
        A lookup table for ALL doc objects of all modules that share this context,
        mainly used in `Module.find_ident()`.
        &#34;&#34;&#34;
        assert isinstance(self._context, Context), \
            &#39;pdoc.Module(context=) should be a pdoc.Context instance&#39;

        self.supermodule = supermodule
        &#34;&#34;&#34;
        The parent `pdoc.Module` this module is a submodule of, or `None`.
        &#34;&#34;&#34;

        self.doc: Dict[str, Union[Module, Class, Function, Variable]] = {}
        &#34;&#34;&#34;A mapping from identifier name to a documentation object.&#34;&#34;&#34;

        self._is_inheritance_linked = False
        &#34;&#34;&#34;Re-entry guard for `pdoc.Module._link_inheritance()`.&#34;&#34;&#34;

        self._skipped_submodules = set()

        var_docstrings, _ = _pep224_docstrings(self)

        # Populate self.doc with this module&#39;s public members
        public_objs = []
        if hasattr(self.obj, &#39;__all__&#39;):
            for name in self.obj.__all__:
                try:
                    obj = getattr(self.obj, name)
                except AttributeError:
                    warn(f&#34;Module {self.module!r} doesn&#39;t contain identifier `{name}` &#34;
                         &#34;exported in `__all__`&#34;)
                else:
                    if not _is_blacklisted(name, self):
                        obj = inspect.unwrap(obj)
                    public_objs.append((name, obj))
        else:
            def is_from_this_module(obj):
                mod = inspect.getmodule(inspect.unwrap(obj))
                return mod is None or mod.__name__ == self.obj.__name__

            for name, obj in inspect.getmembers(self.obj):
                if ((_is_public(name) or
                     _is_whitelisted(name, self)) and
                        (_is_blacklisted(name, self) or  # skips unwrapping that follows
                         is_from_this_module(obj) or
                         name in var_docstrings)):

                    if _is_blacklisted(name, self):
                        self._context.blacklisted.add(f&#39;{self.refname}.{name}&#39;)
                        continue

                    obj = inspect.unwrap(obj)
                    public_objs.append((name, obj))

            index = list(self.obj.__dict__).index
            public_objs.sort(key=lambda i: index(i[0]))

        for name, obj in public_objs:
            if _is_function(obj):
                self.doc[name] = Function(name, self, obj)
            elif inspect.isclass(obj):
                self.doc[name] = Class(name, self, obj)
            elif name in var_docstrings:
                self.doc[name] = Variable(name, self, var_docstrings[name], obj=obj)

        # If the module is a package, scan the directory for submodules
        if self.is_package:

            def iter_modules(paths):
                &#34;&#34;&#34;
                Custom implementation of `pkgutil.iter_modules()`
                because that one doesn&#39;t play well with namespace packages.
                See: https://github.com/pypa/setuptools/issues/83
                &#34;&#34;&#34;
                from os.path import isdir, join
                for pth in paths:
                    if pth.startswith(&#34;__editable__.&#34;):
                        # See https://github.com/pypa/pip/issues/11380
                        continue
                    for file in os.listdir(pth):
                        if file.startswith((&#39;.&#39;, &#39;__pycache__&#39;, &#39;__init__.py&#39;)):
                            continue
                        module_name = inspect.getmodulename(file)
                        if module_name:
                            yield module_name
                        if isdir(join(pth, file)) and &#39;.&#39; not in file:
                            yield file

            for root in iter_modules(self.obj.__path__):
                # Ignore if this module was already doc&#39;d.
                if root in self.doc:
                    continue

                # Ignore if it isn&#39;t exported
                if not _is_public(root) and not _is_whitelisted(root, self):
                    continue
                if _is_blacklisted(root, self):
                    self._skipped_submodules.add(root)
                    continue

                assert self.refname == self.name
                fullname = f&#34;{self.name}.{root}&#34;
                m = Module(import_module(fullname, skip_errors=skip_errors),
                           docfilter=docfilter, supermodule=self,
                           context=self._context, skip_errors=skip_errors)

                self.doc[root] = m
                # Skip empty namespace packages because they may
                # as well be other auxiliary directories
                if m.is_namespace and not m.doc:
                    del self.doc[root]
                    self._context.pop(m.refname)

        # Apply docfilter
        if docfilter:
            for name, dobj in self.doc.copy().items():
                if not docfilter(dobj):
                    self.doc.pop(name)
                    self._context.pop(dobj.refname, None)

        # Build the reference name dictionary of the module
        self._context[self.refname] = self
        for docobj in self.doc.values():
            self._context[docobj.refname] = docobj
            if isinstance(docobj, Class):
                self._context.update((obj.refname, obj)
                                     for obj in docobj.doc.values())

    class ImportWarning(UserWarning):
        &#34;&#34;&#34;
        Our custom import warning because the builtin is ignored by default.
        https://docs.python.org/3/library/warnings.html#default-warning-filter
        &#34;&#34;&#34;

    __pdoc__[&#39;Module.ImportWarning&#39;] = False

    @property
    def __pdoc__(self) -&gt; dict:
        &#34;&#34;&#34;This module&#39;s __pdoc__ dict, or an empty dict if none.&#34;&#34;&#34;
        return getattr(self.obj, &#39;__pdoc__&#39;, {})

    def _link_inheritance(self):
        # Inherited members are already in place since
        # `Class._fill_inheritance()` has been called from
        # `pdoc.fill_inheritance()`.
        # Now look for docstrings in the module&#39;s __pdoc__ override.

        if self._is_inheritance_linked:
            # Prevent re-linking inheritance for modules which have already
            # had done so. Otherwise, this would raise &#34;does not exist&#34;
            # errors if `pdoc.link_inheritance()` is called multiple times.
            return

        # Apply __pdoc__ overrides
        for name, docstring in self.__pdoc__.items():
            # In case of whitelisting with &#34;True&#34;, there&#39;s nothing to do
            if docstring is True:
                continue

            refname = f&#34;{self.refname}.{name}&#34;
            if docstring in (False, None):
                if docstring is None:
                    warn(&#39;Setting `__pdoc__[key] = None` is deprecated; &#39;
                         &#39;use `__pdoc__[key] = False` &#39;
                         f&#39;(key: {name!r}, module: {self.name!r}).&#39;)

                if name in self._skipped_submodules:
                    continue

                if (not name.endswith(&#39;.__init__&#39;) and
                        name not in self.doc and
                        refname not in self._context and
                        refname not in self._context.blacklisted):
                    warn(f&#39;__pdoc__-overriden key {name!r} does not exist &#39;
                         f&#39;in module {self.name!r}&#39;)

                obj = self.find_ident(name)
                cls = getattr(obj, &#39;cls&#39;, None)
                if cls:
                    del cls.doc[obj.name]
                self.doc.pop(name, None)
                self._context.pop(refname, None)

                # Pop also all that startwith refname
                for key in list(self._context.keys()):
                    if key.startswith(refname + &#39;.&#39;):
                        del self._context[key]

                continue

            dobj = self.find_ident(refname)
            if isinstance(dobj, External):
                continue
            if not isinstance(docstring, str):
                raise ValueError(&#39;__pdoc__ dict values must be strings; &#39;
                                 f&#39;__pdoc__[{name!r}] is of type {type(docstring)}&#39;)
            dobj.docstring = inspect.cleandoc(docstring)

        # Now after docstrings are set correctly, continue the
        # inheritance routine, marking members inherited or not
        for c in _filter_type(Class, self.doc):
            c._link_inheritance()

        self._is_inheritance_linked = True

    def text(self, **kwargs) -&gt; str:
        &#34;&#34;&#34;
        Returns the documentation for this module as plain text.
        &#34;&#34;&#34;
        txt = _render_template(&#39;/text.mako&#39;, module=self, **kwargs)
        return re.sub(&#34;\n\n\n+&#34;, &#34;\n\n&#34;, txt)

    def html(self, minify=True, **kwargs) -&gt; str:
        &#34;&#34;&#34;
        Returns the documentation for this module as
        self-contained HTML.

        If `minify` is `True`, the resulting HTML is minified.

        For explanation of other arguments, see `pdoc.html()`.

        `kwargs` is passed to the `mako` render function.
        &#34;&#34;&#34;
        html = _render_template(&#39;/html.mako&#39;, module=self, **kwargs)
        if minify:
            from pdoc.html_helpers import minify_html
            html = minify_html(html)
        if not html.endswith(&#39;\n&#39;):
            html = html + &#39;\n&#39;
        return html

    @property
    def is_package(self) -&gt; bool:
        &#34;&#34;&#34;
        `True` if this module is a package.

        Works by checking whether the module has a `__path__` attribute.
        &#34;&#34;&#34;
        return hasattr(self.obj, &#34;__path__&#34;)

    @property
    def is_namespace(self) -&gt; bool:
        &#34;&#34;&#34;
        `True` if this module is a namespace package.
        &#34;&#34;&#34;
        try:
            return self.obj.__spec__.origin in (None, &#39;namespace&#39;)  # None in Py3.7+
        except AttributeError:
            return False

    def find_class(self, cls: type) -&gt; Doc:
        &#34;&#34;&#34;
        Given a Python `cls` object, try to find it in this module
        or in any of the exported identifiers of the submodules.
        &#34;&#34;&#34;
        # XXX: Is this corrent? Does it always match
        # `Class.module.name + Class.qualname`?. Especially now?
        # If not, see what was here before.
        return self.find_ident(f&#39;{cls.__module__ or _UNKNOWN_MODULE}.{cls.__qualname__}&#39;)

    def find_ident(self, name: str) -&gt; Doc:
        &#34;&#34;&#34;
        Searches this module and **all** other public modules
        for an identifier with name `name` in its list of
        exported identifiers.

        The documentation object corresponding to the identifier is
        returned. If one cannot be found, then an instance of
        `External` is returned populated with the given identifier.
        &#34;&#34;&#34;
        _name = name.rstrip(&#39;()&#39;)  # Function specified with parentheses

        if _name.endswith(&#39;.__init__&#39;):  # Ref to class&#39; init is ref to class itself
            _name = _name[:-len(&#39;.__init__&#39;)]

        return (self.doc.get(_name) or
                self._context.get(_name) or
                self._context.get(f&#39;{self.name}.{_name}&#39;) or
                External(name))

    def _filter_doc_objs(self, type: Type[T], sort=True) -&gt; List[T]:
        result = _filter_type(type, self.doc)
        return sorted(result) if sort else result

    def variables(self, sort=True) -&gt; List[&#39;Variable&#39;]:
        &#34;&#34;&#34;
        Returns all documented module-level variables in the module,
        optionally sorted alphabetically, as a list of `pdoc.Variable`.
        &#34;&#34;&#34;
        return self._filter_doc_objs(Variable, sort)

    def classes(self, sort=True) -&gt; List[&#39;Class&#39;]:
        &#34;&#34;&#34;
        Returns all documented module-level classes in the module,
        optionally sorted alphabetically, as a list of `pdoc.Class`.
        &#34;&#34;&#34;
        return self._filter_doc_objs(Class, sort)

    def functions(self, sort=True) -&gt; List[&#39;Function&#39;]:
        &#34;&#34;&#34;
        Returns all documented module-level functions in the module,
        optionally sorted alphabetically, as a list of `pdoc.Function`.
        &#34;&#34;&#34;
        return self._filter_doc_objs(Function, sort)

    def submodules(self) -&gt; List[&#39;Module&#39;]:
        &#34;&#34;&#34;
        Returns all documented sub-modules of the module sorted
        alphabetically as a list of `pdoc.Module`.
        &#34;&#34;&#34;
        return self._filter_doc_objs(Module)

    def _url(self):
        url = self.module.name.replace(&#39;.&#39;, &#39;/&#39;)
        if self.is_package:
            return url + _URL_PACKAGE_SUFFIX
        elif url.endswith(&#39;/index&#39;):
            return url + _URL_INDEX_MODULE_SUFFIX
        return url + _URL_MODULE_SUFFIX</code></pre>
</details>
<div class="desc"><p>Representation of a module's documentation.</p>
<p>Creates a <code><a title="pdoc.Module" href="#pdoc.Module">Module</a></code> documentation object given the actual
module Python object.</p>
<p><code>docfilter</code> is an optional predicate that controls which
sub-objects are documentated (see also: <code><a title="pdoc.html" href="#pdoc.html">html()</a></code>).</p>
<p><code>supermodule</code> is the parent <code><a title="pdoc.Module" href="#pdoc.Module">Module</a></code> this module is
a submodule of.</p>
<p><code>context</code> is an instance of <code><a title="pdoc.Context" href="#pdoc.Context">Context</a></code>. If <code>None</code> a
global context object will be used.</p>
<p>If <code>skip_errors</code> is <code>True</code> and an unimportable, erroneous
submodule is encountered, a warning will be issued instead
of raising an exception.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pdoc.Doc" href="#pdoc.Doc">Doc</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pdoc.Module.doc"><code class="name">var <span class="ident">doc</span></code></dt>
<dd>
<div class="desc"><p>A mapping from identifier name to a documentation object.</p></div>
</dd>
<dt id="pdoc.Module.is_namespace"><code class="name">prop <span class="ident">is_namespace</span> :Â bool</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdoc3/pdoc/blob/5570f9a425d7cac7f7071c4c4d17a9edae20dc3d/pdoc/__init__.py#L922-L930" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@property
def is_namespace(self) -&gt; bool:
    &#34;&#34;&#34;
    `True` if this module is a namespace package.
    &#34;&#34;&#34;
    try:
        return self.obj.__spec__.origin in (None, &#39;namespace&#39;)  # None in Py3.7+
    except AttributeError:
        return False</code></pre>
</details>
<div class="desc"><p><code>True</code> if this module is a namespace package.</p></div>
</dd>
<dt id="pdoc.Module.is_package"><code class="name">prop <span class="ident">is_package</span> :Â bool</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdoc3/pdoc/blob/5570f9a425d7cac7f7071c4c4d17a9edae20dc3d/pdoc/__init__.py#L913-L920" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@property
def is_package(self) -&gt; bool:
    &#34;&#34;&#34;
    `True` if this module is a package.

    Works by checking whether the module has a `__path__` attribute.
    &#34;&#34;&#34;
    return hasattr(self.obj, &#34;__path__&#34;)</code></pre>
</details>
<div class="desc"><p><code>True</code> if this module is a package.</p>
<p>Works by checking whether the module has a <code>__path__</code> attribute.</p></div>
</dd>
<dt id="pdoc.Module.supermodule"><code class="name">var <span class="ident">supermodule</span></code></dt>
<dd>
<div class="desc"><p>The parent <code><a title="pdoc.Module" href="#pdoc.Module">Module</a></code> this module is a submodule of, or <code>None</code>.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pdoc.Module.classes"><code class="name flex">
<span>def <span class="ident">classes</span></span>(<span>self, sort=True) â€‘>Â List[<a title="pdoc.Class" href="#pdoc.Class">Class</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdoc3/pdoc/blob/5570f9a425d7cac7f7071c4c4d17a9edae20dc3d/pdoc/__init__.py#L973-L978" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def classes(self, sort=True) -&gt; List[&#39;Class&#39;]:
    &#34;&#34;&#34;
    Returns all documented module-level classes in the module,
    optionally sorted alphabetically, as a list of `pdoc.Class`.
    &#34;&#34;&#34;
    return self._filter_doc_objs(Class, sort)</code></pre>
</details>
<div class="desc"><p>Returns all documented module-level classes in the module,
optionally sorted alphabetically, as a list of <code><a title="pdoc.Class" href="#pdoc.Class">Class</a></code>.</p></div>
</dd>
<dt id="pdoc.Module.find_class"><code class="name flex">
<span>def <span class="ident">find_class</span></span>(<span>self, cls:Â type) â€‘>Â <a title="pdoc.Doc" href="#pdoc.Doc">Doc</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdoc3/pdoc/blob/5570f9a425d7cac7f7071c4c4d17a9edae20dc3d/pdoc/__init__.py#L932-L940" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def find_class(self, cls: type) -&gt; Doc:
    &#34;&#34;&#34;
    Given a Python `cls` object, try to find it in this module
    or in any of the exported identifiers of the submodules.
    &#34;&#34;&#34;
    # XXX: Is this corrent? Does it always match
    # `Class.module.name + Class.qualname`?. Especially now?
    # If not, see what was here before.
    return self.find_ident(f&#39;{cls.__module__ or _UNKNOWN_MODULE}.{cls.__qualname__}&#39;)</code></pre>
</details>
<div class="desc"><p>Given a Python <code>cls</code> object, try to find it in this module
or in any of the exported identifiers of the submodules.</p></div>
</dd>
<dt id="pdoc.Module.find_ident"><code class="name flex">
<span>def <span class="ident">find_ident</span></span>(<span>self, name:Â str) â€‘>Â <a title="pdoc.Doc" href="#pdoc.Doc">Doc</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdoc3/pdoc/blob/5570f9a425d7cac7f7071c4c4d17a9edae20dc3d/pdoc/__init__.py#L942-L960" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def find_ident(self, name: str) -&gt; Doc:
    &#34;&#34;&#34;
    Searches this module and **all** other public modules
    for an identifier with name `name` in its list of
    exported identifiers.

    The documentation object corresponding to the identifier is
    returned. If one cannot be found, then an instance of
    `External` is returned populated with the given identifier.
    &#34;&#34;&#34;
    _name = name.rstrip(&#39;()&#39;)  # Function specified with parentheses

    if _name.endswith(&#39;.__init__&#39;):  # Ref to class&#39; init is ref to class itself
        _name = _name[:-len(&#39;.__init__&#39;)]

    return (self.doc.get(_name) or
            self._context.get(_name) or
            self._context.get(f&#39;{self.name}.{_name}&#39;) or
            External(name))</code></pre>
</details>
<div class="desc"><p>Searches this module and <strong>all</strong> other public modules
for an identifier with name <code>name</code> in its list of
exported identifiers.</p>
<p>The documentation object corresponding to the identifier is
returned. If one cannot be found, then an instance of
<code><a title="pdoc.External" href="#pdoc.External">External</a></code> is returned populated with the given identifier.</p></div>
</dd>
<dt id="pdoc.Module.functions"><code class="name flex">
<span>def <span class="ident">functions</span></span>(<span>self, sort=True) â€‘>Â List[<a title="pdoc.Function" href="#pdoc.Function">Function</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdoc3/pdoc/blob/5570f9a425d7cac7f7071c4c4d17a9edae20dc3d/pdoc/__init__.py#L980-L985" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def functions(self, sort=True) -&gt; List[&#39;Function&#39;]:
    &#34;&#34;&#34;
    Returns all documented module-level functions in the module,
    optionally sorted alphabetically, as a list of `pdoc.Function`.
    &#34;&#34;&#34;
    return self._filter_doc_objs(Function, sort)</code></pre>
</details>
<div class="desc"><p>Returns all documented module-level functions in the module,
optionally sorted alphabetically, as a list of <code><a title="pdoc.Function" href="#pdoc.Function">Function</a></code>.</p></div>
</dd>
<dt id="pdoc.Module.html"><code class="name flex">
<span>def <span class="ident">html</span></span>(<span>self, minify=True, **kwargs) â€‘>Â str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdoc3/pdoc/blob/5570f9a425d7cac7f7071c4c4d17a9edae20dc3d/pdoc/__init__.py#L894-L911" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def html(self, minify=True, **kwargs) -&gt; str:
    &#34;&#34;&#34;
    Returns the documentation for this module as
    self-contained HTML.

    If `minify` is `True`, the resulting HTML is minified.

    For explanation of other arguments, see `pdoc.html()`.

    `kwargs` is passed to the `mako` render function.
    &#34;&#34;&#34;
    html = _render_template(&#39;/html.mako&#39;, module=self, **kwargs)
    if minify:
        from pdoc.html_helpers import minify_html
        html = minify_html(html)
    if not html.endswith(&#39;\n&#39;):
        html = html + &#39;\n&#39;
    return html</code></pre>
</details>
<div class="desc"><p>Returns the documentation for this module as
self-contained HTML.</p>
<p>If <code>minify</code> is <code>True</code>, the resulting HTML is minified.</p>
<p>For explanation of other arguments, see <code><a title="pdoc.html" href="#pdoc.html">html()</a></code>.</p>
<p><code>kwargs</code> is passed to the <code>mako</code> render function.</p></div>
</dd>
<dt id="pdoc.Module.submodules"><code class="name flex">
<span>def <span class="ident">submodules</span></span>(<span>self) â€‘>Â List[<a title="pdoc.Module" href="#pdoc.Module">Module</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdoc3/pdoc/blob/5570f9a425d7cac7f7071c4c4d17a9edae20dc3d/pdoc/__init__.py#L987-L992" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def submodules(self) -&gt; List[&#39;Module&#39;]:
    &#34;&#34;&#34;
    Returns all documented sub-modules of the module sorted
    alphabetically as a list of `pdoc.Module`.
    &#34;&#34;&#34;
    return self._filter_doc_objs(Module)</code></pre>
</details>
<div class="desc"><p>Returns all documented sub-modules of the module sorted
alphabetically as a list of <code><a title="pdoc.Module" href="#pdoc.Module">Module</a></code>.</p></div>
</dd>
<dt id="pdoc.Module.text"><code class="name flex">
<span>def <span class="ident">text</span></span>(<span>self, **kwargs) â€‘>Â str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdoc3/pdoc/blob/5570f9a425d7cac7f7071c4c4d17a9edae20dc3d/pdoc/__init__.py#L887-L892" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def text(self, **kwargs) -&gt; str:
    &#34;&#34;&#34;
    Returns the documentation for this module as plain text.
    &#34;&#34;&#34;
    txt = _render_template(&#39;/text.mako&#39;, module=self, **kwargs)
    return re.sub(&#34;\n\n\n+&#34;, &#34;\n\n&#34;, txt)</code></pre>
</details>
<div class="desc"><p>Returns the documentation for this module as plain text.</p></div>
</dd>
<dt id="pdoc.Module.variables"><code class="name flex">
<span>def <span class="ident">variables</span></span>(<span>self, sort=True) â€‘>Â List[<a title="pdoc.Variable" href="#pdoc.Variable">Variable</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdoc3/pdoc/blob/5570f9a425d7cac7f7071c4c4d17a9edae20dc3d/pdoc/__init__.py#L966-L971" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def variables(self, sort=True) -&gt; List[&#39;Variable&#39;]:
    &#34;&#34;&#34;
    Returns all documented module-level variables in the module,
    optionally sorted alphabetically, as a list of `pdoc.Variable`.
    &#34;&#34;&#34;
    return self._filter_doc_objs(Variable, sort)</code></pre>
</details>
<div class="desc"><p>Returns all documented module-level variables in the module,
optionally sorted alphabetically, as a list of <code><a title="pdoc.Variable" href="#pdoc.Variable">Variable</a></code>.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pdoc.Doc" href="#pdoc.Doc">Doc</a></b></code>:
<ul class="hlist">
<li><code><a title="pdoc.Doc.docstring" href="#pdoc.Doc.docstring">docstring</a></code></li>
<li><code><a title="pdoc.Doc.inherits" href="#pdoc.Doc.inherits">inherits</a></code></li>
<li><code><a title="pdoc.Doc.module" href="#pdoc.Doc.module">module</a></code></li>
<li><code><a title="pdoc.Doc.name" href="#pdoc.Doc.name">name</a></code></li>
<li><code><a title="pdoc.Doc.obj" href="#pdoc.Doc.obj">obj</a></code></li>
<li><code><a title="pdoc.Doc.qualname" href="#pdoc.Doc.qualname">qualname</a></code></li>
<li><code><a title="pdoc.Doc.refname" href="#pdoc.Doc.refname">refname</a></code></li>
<li><code><a title="pdoc.Doc.source" href="#pdoc.Doc.source">source</a></code></li>
<li><code><a title="pdoc.Doc.url" href="#pdoc.Doc.url">url</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pdoc.Variable"><code class="flex name class">
<span>class <span class="ident">Variable</span></span>
<span>(</span><span>name:Â str,<br>module:Â <a title="pdoc.Module" href="#pdoc.Module">Module</a>,<br>docstring,<br>*,<br>obj=None,<br>cls:Â <a title="pdoc.Class" href="#pdoc.Class">Class</a>Â |Â NoneÂ =Â None,<br>instance_var:Â boolÂ =Â False,<br>kind:Â Literal['prop',Â 'var']Â =Â 'var')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdoc3/pdoc/blob/5570f9a425d7cac7f7071c4c4d17a9edae20dc3d/pdoc/__init__.py#L1640-L1685" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class Variable(Doc):
    &#34;&#34;&#34;
    Representation of a variable&#39;s documentation. This includes
    module, class, and instance variables.
    &#34;&#34;&#34;
    def __init__(self, name: str, module: Module, docstring, *,
                 obj=None, cls: Optional[Class] = None, instance_var: bool = False,
                 kind: Literal[&#34;prop&#34;, &#34;var&#34;] = &#39;var&#39;):
        &#34;&#34;&#34;
        Same as `pdoc.Doc`, except `cls` should be provided
        as a `pdoc.Class` object when this is a class or instance
        variable.
        &#34;&#34;&#34;
        super().__init__(name, module, obj, docstring)

        self.cls = cls
        &#34;&#34;&#34;
        The `pdoc.Class` object if this is a class or instance
        variable. If not (i.e. it is a global variable), this is None.
        &#34;&#34;&#34;

        self.instance_var = instance_var
        &#34;&#34;&#34;
        True if variable is some class&#39; instance variable (as
        opposed to class variable).
        &#34;&#34;&#34;

        self.kind = kind
        &#34;&#34;&#34;
        `prop` if variable is a dynamic property (has getter/setter or deleter),
        or `var` otherwise.
        &#34;&#34;&#34;

    @property
    def qualname(self) -&gt; str:
        if self.cls:
            return f&#39;{self.cls.qualname}.{self.name}&#39;
        return self.name

    @property
    def refname(self) -&gt; str:
        return f&#39;{self.cls.refname if self.cls else self.module.refname}.{self.name}&#39;

    def type_annotation(self, *, link=None) -&gt; str:
        &#34;&#34;&#34;Formatted variable type annotation or empty string if none.&#34;&#34;&#34;
        return Function.return_annotation(cast(Function, self), link=link)</code></pre>
</details>
<div class="desc"><p>Representation of a variable's documentation. This includes
module, class, and instance variables.</p>
<p>Same as <code><a title="pdoc.Doc" href="#pdoc.Doc">Doc</a></code>, except <code>cls</code> should be provided
as a <code><a title="pdoc.Class" href="#pdoc.Class">Class</a></code> object when this is a class or instance
variable.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pdoc.Doc" href="#pdoc.Doc">Doc</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pdoc.Variable.cls"><code class="name">var <span class="ident">cls</span></code></dt>
<dd>
<div class="desc"><p>The <code><a title="pdoc.Class" href="#pdoc.Class">Class</a></code> object if this is a class or instance
variable. If not (i.e. it is a global variable), this is None.</p></div>
</dd>
<dt id="pdoc.Variable.instance_var"><code class="name">var <span class="ident">instance_var</span></code></dt>
<dd>
<div class="desc"><p>True if variable is some class' instance variable (as
opposed to class variable).</p></div>
</dd>
<dt id="pdoc.Variable.kind"><code class="name">var <span class="ident">kind</span></code></dt>
<dd>
<div class="desc"><p><code>prop</code> if variable is a dynamic property (has getter/setter or deleter),
or <code>var</code> otherwise.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pdoc.Variable.type_annotation"><code class="name flex">
<span>def <span class="ident">type_annotation</span></span>(<span>self, *, link=None) â€‘>Â str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdoc3/pdoc/blob/5570f9a425d7cac7f7071c4c4d17a9edae20dc3d/pdoc/__init__.py#L1683-L1685" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def type_annotation(self, *, link=None) -&gt; str:
    &#34;&#34;&#34;Formatted variable type annotation or empty string if none.&#34;&#34;&#34;
    return Function.return_annotation(cast(Function, self), link=link)</code></pre>
</details>
<div class="desc"><p>Formatted variable type annotation or empty string if none.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pdoc.Doc" href="#pdoc.Doc">Doc</a></b></code>:
<ul class="hlist">
<li><code><a title="pdoc.Doc.docstring" href="#pdoc.Doc.docstring">docstring</a></code></li>
<li><code><a title="pdoc.Doc.inherits" href="#pdoc.Doc.inherits">inherits</a></code></li>
<li><code><a title="pdoc.Doc.module" href="#pdoc.Doc.module">module</a></code></li>
<li><code><a title="pdoc.Doc.name" href="#pdoc.Doc.name">name</a></code></li>
<li><code><a title="pdoc.Doc.obj" href="#pdoc.Doc.obj">obj</a></code></li>
<li><code><a title="pdoc.Doc.qualname" href="#pdoc.Doc.qualname">qualname</a></code></li>
<li><code><a title="pdoc.Doc.refname" href="#pdoc.Doc.refname">refname</a></code></li>
<li><code><a title="pdoc.Doc.source" href="#pdoc.Doc.source">source</a></code></li>
<li><code><a title="pdoc.Doc.url" href="#pdoc.Doc.url">url</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="pdoc Home" href="https://pdoc3.github.io/pdoc/">
<img src="https://pdoc3.github.io/pdoc/logo.png" alt=""> pdoc
</a>
</header>
<div class="gcse-search" style="height: 70px"
data-as_oq="site:pdoc3.github.io inurl:github.com/pdoc3"
data-gaCategoryParameter="pdoc">
</div>
<div class="toc">
<ul>
<li><a href="#what-objects-are-documented">What objects are documented?</a></li>
<li><a href="#where-does-pdoc-get-documentation-from">Where does pdoc get documentation from?</a><ul>
<li><a href="#docstrings-inheritance">Docstrings inheritance</a></li>
<li><a href="#docstrings-for-variables">Docstrings for variables</a></li>
</ul>
</li>
<li><a href="#overriding-docstrings-with-__pdoc__">Overriding docstrings with __pdoc__</a></li>
<li><a href="#supported-docstring-formats">Supported docstring formats</a><ul>
<li><a href="#supported-rest-directives">Supported reST directives</a></li>
</ul>
</li>
<li><a href="#linking-to-other-identifiers">Linking to other identifiers</a></li>
<li><a href="#command-line-interface">Command-line interface</a></li>
<li><a href="#programmatic-usage">Programmatic usage</a></li>
<li><a href="#custom-templates">Custom templates</a></li>
<li><a href="#compatibility">Compatibility</a></li>
<li><a href="#contributing">Contributing</a></li>
<li><a href="#license">License</a></li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="pdoc.cli" href="cli.html">pdoc.cli</a></code></li>
<li><code><a title="pdoc.html_helpers" href="html_helpers.html">pdoc.html_helpers</a></code></li>
<li><code><a title="pdoc.test" href="test/index.html">pdoc.test</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="pdoc.tpl_lookup" href="#pdoc.tpl_lookup">tpl_lookup</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="pdoc.html" href="#pdoc.html">html</a></code></li>
<li><code><a title="pdoc.import_module" href="#pdoc.import_module">import_module</a></code></li>
<li><code><a title="pdoc.link_inheritance" href="#pdoc.link_inheritance">link_inheritance</a></code></li>
<li><code><a title="pdoc.maybe_lru_cache" href="#pdoc.maybe_lru_cache">maybe_lru_cache</a></code></li>
<li><code><a title="pdoc.reset" href="#pdoc.reset">reset</a></code></li>
<li><code><a title="pdoc.text" href="#pdoc.text">text</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pdoc.Class" href="#pdoc.Class">Class</a></code></h4>
<ul class="two-column">
<li><code><a title="pdoc.Class.class_variables" href="#pdoc.Class.class_variables">class_variables</a></code></li>
<li><code><a title="pdoc.Class.doc" href="#pdoc.Class.doc">doc</a></code></li>
<li><code><a title="pdoc.Class.functions" href="#pdoc.Class.functions">functions</a></code></li>
<li><code><a title="pdoc.Class.inherited_members" href="#pdoc.Class.inherited_members">inherited_members</a></code></li>
<li><code><a title="pdoc.Class.instance_variables" href="#pdoc.Class.instance_variables">instance_variables</a></code></li>
<li><code><a title="pdoc.Class.methods" href="#pdoc.Class.methods">methods</a></code></li>
<li><code><a title="pdoc.Class.mro" href="#pdoc.Class.mro">mro</a></code></li>
<li><code><a title="pdoc.Class.params" href="#pdoc.Class.params">params</a></code></li>
<li><code><a title="pdoc.Class.subclasses" href="#pdoc.Class.subclasses">subclasses</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pdoc.Context" href="#pdoc.Context">Context</a></code></h4>
</li>
<li>
<h4><code><a title="pdoc.Doc" href="#pdoc.Doc">Doc</a></code></h4>
<ul class="two-column">
<li><code><a title="pdoc.Doc.docstring" href="#pdoc.Doc.docstring">docstring</a></code></li>
<li><code><a title="pdoc.Doc.inherits" href="#pdoc.Doc.inherits">inherits</a></code></li>
<li><code><a title="pdoc.Doc.module" href="#pdoc.Doc.module">module</a></code></li>
<li><code><a title="pdoc.Doc.name" href="#pdoc.Doc.name">name</a></code></li>
<li><code><a title="pdoc.Doc.obj" href="#pdoc.Doc.obj">obj</a></code></li>
<li><code><a title="pdoc.Doc.qualname" href="#pdoc.Doc.qualname">qualname</a></code></li>
<li><code><a title="pdoc.Doc.refname" href="#pdoc.Doc.refname">refname</a></code></li>
<li><code><a title="pdoc.Doc.source" href="#pdoc.Doc.source">source</a></code></li>
<li><code><a title="pdoc.Doc.url" href="#pdoc.Doc.url">url</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pdoc.External" href="#pdoc.External">External</a></code></h4>
<ul class="">
<li><code><a title="pdoc.External.url" href="#pdoc.External.url">url</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pdoc.Function" href="#pdoc.Function">Function</a></code></h4>
<ul class="">
<li><code><a title="pdoc.Function.cls" href="#pdoc.Function.cls">cls</a></code></li>
<li><code><a title="pdoc.Function.funcdef" href="#pdoc.Function.funcdef">funcdef</a></code></li>
<li><code><a title="pdoc.Function.is_method" href="#pdoc.Function.is_method">is_method</a></code></li>
<li><code><a title="pdoc.Function.params" href="#pdoc.Function.params">params</a></code></li>
<li><code><a title="pdoc.Function.return_annotation" href="#pdoc.Function.return_annotation">return_annotation</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pdoc.Module" href="#pdoc.Module">Module</a></code></h4>
<ul class="two-column">
<li><code><a title="pdoc.Module.classes" href="#pdoc.Module.classes">classes</a></code></li>
<li><code><a title="pdoc.Module.doc" href="#pdoc.Module.doc">doc</a></code></li>
<li><code><a title="pdoc.Module.find_class" href="#pdoc.Module.find_class">find_class</a></code></li>
<li><code><a title="pdoc.Module.find_ident" href="#pdoc.Module.find_ident">find_ident</a></code></li>
<li><code><a title="pdoc.Module.functions" href="#pdoc.Module.functions">functions</a></code></li>
<li><code><a title="pdoc.Module.html" href="#pdoc.Module.html">html</a></code></li>
<li><code><a title="pdoc.Module.is_namespace" href="#pdoc.Module.is_namespace">is_namespace</a></code></li>
<li><code><a title="pdoc.Module.is_package" href="#pdoc.Module.is_package">is_package</a></code></li>
<li><code><a title="pdoc.Module.submodules" href="#pdoc.Module.submodules">submodules</a></code></li>
<li><code><a title="pdoc.Module.supermodule" href="#pdoc.Module.supermodule">supermodule</a></code></li>
<li><code><a title="pdoc.Module.text" href="#pdoc.Module.text">text</a></code></li>
<li><code><a title="pdoc.Module.variables" href="#pdoc.Module.variables">variables</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pdoc.Variable" href="#pdoc.Variable">Variable</a></code></h4>
<ul class="">
<li><code><a title="pdoc.Variable.cls" href="#pdoc.Variable.cls">cls</a></code></li>
<li><code><a title="pdoc.Variable.instance_var" href="#pdoc.Variable.instance_var">instance_var</a></code></li>
<li><code><a title="pdoc.Variable.kind" href="#pdoc.Variable.kind">kind</a></code></li>
<li><code><a title="pdoc.Variable.type_annotation" href="#pdoc.Variable.type_annotation">type_annotation</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p><span style="color:#ddd">&#21328;</span></p>
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
