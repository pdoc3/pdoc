<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.4" />
<title>pdoc.cli API documentation</title>
<meta name="description" content="pdoc&#39;s CLI interface and helper functions." />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:#555;padding-bottom:.5em;border-bottom:1px solid silver}.homelink:hover{color:inherit}.homelink img{max-width:20%;max-height:5em;margin:auto;margin-bottom:.3em}</style>
<link rel="canonical" href="https://pdoc3.github.io/pdoc/doc/pdoc/cli.html">
<link rel="icon" href="https://pdoc.github.io/pdoc/logo.png">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle=window.adsbygoogle||[]).push({google_ad_client:"ca-pub-2900001379782823",enable_page_level_ads:true});</script></head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pdoc.cli</code></h1>
</header>
<section id="section-intro">
<p>pdoc's CLI interface and helper functions.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdoc3/pdoc/blob/c9d9118e1a2df4debc485e2d5b2118cd79f60994/pdoc/cli.py#L0-L499" class="git-link">Browse git</a>
</summary>
<pre><code class="python">#!/usr/bin/env python3
&#34;&#34;&#34;pdoc&#39;s CLI interface and helper functions.&#34;&#34;&#34;

import argparse
import ast
import importlib
import inspect
import os
import os.path as path
import re
import sys
import warnings
from http.server import BaseHTTPRequestHandler, HTTPServer
from typing import Sequence
from warnings import warn

import pdoc

parser = argparse.ArgumentParser(
    description=&#34;Automatically generate API docs for Python modules.&#34;,
    epilog=&#34;Further documentation is available at &lt;https://pdoc3.github.io/pdoc/doc&gt;.&#34;,
)
aa = parser.add_argument
mode_aa = parser.add_mutually_exclusive_group().add_argument

aa(
    &#39;--version&#39;, action=&#39;version&#39;, version=&#39;%(prog)s &#39; + pdoc.__version__)
aa(
    &#34;modules&#34;,
    type=str,
    metavar=&#39;MODULE&#39;,
    nargs=&#34;+&#34;,
    help=&#34;The Python module name. This may be an import path resolvable in &#34;
    &#34;the current environment, or a file path to a Python module or &#34;
    &#34;package.&#34;,
)
aa(
    &#34;-c&#34;, &#34;--config&#34;,
    type=str,
    metavar=&#39;OPTION=VALUE&#39;,
    action=&#39;append&#39;,
    default=[],
    help=&#34;Override template options. This is an alternative to using &#34;
         &#34;a custom config.mako file in --template-dir. This option &#34;
         &#34;can be specified multiple times.&#34;,
)
aa(
    &#34;--filter&#34;,
    type=str,
    metavar=&#39;STRING&#39;,
    default=None,
    help=&#34;Comma-separated list of filters. When specified, &#34;
         &#34;only identifiers containing the specified string &#34;
         &#34;will be shown in the output. Search is case sensitive. &#34;
         &#34;Has no effect when --http is set.&#34;,
)
aa(
    &#34;-f&#34;, &#34;--force&#34;,
    action=&#34;store_true&#34;,
    help=&#34;Overwrite any existing generated (--output-dir) files.&#34;,
)
mode_aa(
    &#34;--html&#34;,
    action=&#34;store_true&#34;,
    help=&#34;When set, the output will be HTML formatted.&#34;,
)
mode_aa(
    &#34;--pdf&#34;,
    action=&#34;store_true&#34;,
    help=&#34;When set, the specified modules will be printed to standard output, &#34;
         &#34;formatted in Markdown-Extra, compatible with most &#34;
         &#34;Markdown-(to-HTML-)to-PDF converters.&#34;,
)
aa(
    &#34;--html-dir&#34;,
    type=str,
    help=argparse.SUPPRESS,
)
aa(
    &#34;-o&#34;, &#34;--output-dir&#34;,
    type=str,
    metavar=&#39;DIR&#39;,
    help=&#34;The directory to output generated HTML/markdown files to &#34;
         &#34;(default: ./html for --html).&#34;,
)
aa(
    &#34;--html-no-source&#34;,
    action=&#34;store_true&#34;,
    help=argparse.SUPPRESS,
)
aa(
    &#34;--overwrite&#34;,
    action=&#34;store_true&#34;,
    help=argparse.SUPPRESS,
)
aa(
    &#34;--external-links&#34;,
    action=&#34;store_true&#34;,
    help=argparse.SUPPRESS,
)
aa(
    &#34;--template-dir&#34;,
    type=str,
    metavar=&#39;DIR&#39;,
    default=None,
    help=&#34;Specify a directory containing Mako templates &#34;
         &#34;(html.mako, text.mako, config.mako and/or any templates they include). &#34;
         &#34;Alternatively, put your templates in $XDG_CONFIG_HOME/pdoc and &#34;
         &#34;pdoc will automatically find them.&#34;,
)
aa(
    &#34;--link-prefix&#34;,
    type=str,
    help=argparse.SUPPRESS,
)
aa(
    &#34;--close-stdin&#34;,
    action=&#34;store_true&#34;,
    help=&#34;When set, stdin will be closed before importing, to account for &#34;
         &#34;ill-behaved modules that block on stdin.&#34;
)

DEFAULT_HOST, DEFAULT_PORT = &#39;localhost&#39;, 8080


def _check_host_port(s):
    if s and &#39;:&#39; not in s:
        raise argparse.ArgumentTypeError(
            &#34;&#39;{}&#39; doesn&#39;t match &#39;[HOST]:[PORT]&#39;. &#34;
            &#34;Specify `--http :` to use default hostname and port.&#34;.format(s))
    return s


aa(
    &#34;--http&#34;,
    default=&#39;&#39;,
    type=_check_host_port,
    metavar=&#39;HOST:PORT&#39;,
    help=&#34;When set, pdoc will run as an HTTP server providing documentation &#34;
         &#34;for specified modules. If you just want to use the default hostname &#34;
         &#34;and port ({}:{}), set the parameter to :.&#34;.format(DEFAULT_HOST, DEFAULT_PORT),
)

args = argparse.Namespace()


class WebDoc(BaseHTTPRequestHandler):
    args = None  # Set before server instantiated
    template_config = None

    def do_HEAD(self):
        status = 200
        if self.path != &#34;/&#34;:
            status = self.check_modified()

        self.send_response(status)
        self.send_header(&#34;Content-type&#34;, &#34;text/html; charset=utf-8&#34;)
        self.end_headers()

    def check_modified(self):
        try:
            module = pdoc.import_module(self.import_path_from_req_url)
            new_etag = str(os.stat(module.__file__).st_mtime)
        except ImportError:
            return 404

        old_etag = self.headers.get(&#39;If-None-Match&#39;, new_etag)
        if old_etag == new_etag:
            # Don&#39;t log repeating checks
            self.log_request = lambda *args, **kwargs: None
            return 304

        return 205

    def do_GET(self):
        # Deny favicon shortcut early.
        if self.path == &#34;/favicon.ico&#34;:
            return None

        importlib.invalidate_caches()
        code = 200
        if self.path == &#34;/&#34;:
            modules = [pdoc.import_module(module, reload=True)
                       for module in self.args.modules]
            modules = sorted((module.__name__, inspect.getdoc(module))
                             for module in modules)
            out = pdoc._render_template(&#39;/html.mako&#39;,
                                        modules=modules,
                                        **self.template_config)
        elif self.path.endswith(&#34;.ext&#34;):
            # External links are a bit weird. You should view them as a giant
            # hack. Basically, the idea is to &#34;guess&#34; where something lives
            # when documenting another module and hope that guess can actually
            # track something down in a more global context.
            #
            # The idea here is to start specific by looking for HTML that
            # exists that matches the full external path given. Then trim off
            # one component at the end and try again.
            #
            # If no HTML is found, then we ask `pdoc` to do its thang on the
            # parent module in the external path. If all goes well, that
            # module will then be able to find the external identifier.

            import_path = self.path[:-4].lstrip(&#34;/&#34;)
            resolved = self.resolve_ext(import_path)
            if resolved is None:  # Try to generate the HTML...
                print(&#34;Generating HTML for %s on the fly...&#34; % import_path, file=sys.stderr)
                try:
                    out = pdoc.html(import_path.split(&#34;.&#34;)[0], **self.template_config)
                except Exception as e:
                    print(&#39;Error generating docs: {}&#39;.format(e), file=sys.stderr)
                    # All hope is lost.
                    code = 404
                    out = &#34;External identifier &lt;code&gt;%s&lt;/code&gt; not found.&#34; % import_path
            else:
                return self.redirect(resolved)
        # Redirect &#39;/pdoc&#39; to &#39;/pdoc/&#39; so that relative links work
        # (results in &#39;/pdoc/cli.html&#39; instead of &#39;cli.html&#39;)
        elif not self.path.endswith((&#39;/&#39;, &#39;.html&#39;)):
            return self.redirect(self.path + &#39;/&#39;)
        # Redirect &#39;/pdoc/index.html&#39; to &#39;/pdoc/&#39; so it&#39;s more pretty
        elif self.path.endswith(pdoc._URL_PACKAGE_SUFFIX):
            return self.redirect(self.path[:-len(pdoc._URL_PACKAGE_SUFFIX)] + &#39;/&#39;)
        else:
            try:
                out = self.html()
            except ImportError:
                code = 404
                out = &#34;Module &lt;code&gt;%s&lt;/code&gt; not found.&#34; % self.import_path_from_req_url

        self.send_response(code)
        self.send_header(&#34;Content-type&#34;, &#34;text/html; charset=utf-8&#34;)
        self.end_headers()
        self.echo(out)

    def redirect(self, location):
        self.send_response(302)
        self.send_header(&#34;Location&#34;, location)
        self.end_headers()

    def echo(self, s):
        self.wfile.write(s.encode(&#34;utf-8&#34;))

    def html(self):
        &#34;&#34;&#34;
        Retrieves and sends the HTML belonging to the path given in
        URL. This method is smart and will look for HTML files already
        generated and account for whether they are stale compared to
        the source code.
        &#34;&#34;&#34;
        return pdoc.html(self.import_path_from_req_url,
                         reload=True, http_server=True, external_links=True,
                         **self.template_config)

    def resolve_ext(self, import_path):
        def exists(p):
            p = path.join(args.output_dir, p)
            pkg = path.join(p, pdoc._URL_PACKAGE_SUFFIX.lstrip(&#39;/&#39;))
            mod = p + pdoc._URL_MODULE_SUFFIX

            if path.isfile(pkg):
                return pkg[len(args.output_dir):]
            elif path.isfile(mod):
                return mod[len(args.output_dir):]
            return None

        parts = import_path.split(&#34;.&#34;)
        for i in range(len(parts), 0, -1):
            p = path.join(*parts[0:i])
            realp = exists(p)
            if realp is not None:
                return &#34;/%s#%s&#34; % (realp.lstrip(&#34;/&#34;), import_path)
        return None

    @property
    def import_path_from_req_url(self):
        pth = self.path.split(&#39;#&#39;)[0].lstrip(&#39;/&#39;)
        for suffix in (&#39;/&#39;,
                       pdoc._URL_PACKAGE_SUFFIX,
                       pdoc._URL_INDEX_MODULE_SUFFIX,
                       pdoc._URL_MODULE_SUFFIX):
            if pth.endswith(suffix):
                pth = pth[:-len(suffix)]
                break
        return pth.replace(&#39;/&#39;, &#39;.&#39;)


def module_path(m: pdoc.Module, ext: str):
    return path.join(args.output_dir, *re.sub(r&#39;\.html$&#39;, ext, m.url()).split(&#39;/&#39;))


def _quit_if_exists(m: pdoc.Module, ext: str):
    if args.force:
        return

    paths = [module_path(m, ext)]
    if m.is_package:  # If package, make sure the dir doesn&#39;t exist either
        paths.append(path.dirname(paths[0]))

    for pth in paths:
        if path.lexists(pth):
            print(&#34;File &#39;%s&#39; already exists. Delete it, or run with --force&#34; % pth,
                  file=sys.stderr)
            sys.exit(1)


def write_files(m: pdoc.Module, ext: str, **kwargs):
    assert ext in (&#39;.html&#39;, &#39;.md&#39;)
    f = module_path(m, ext=ext)

    dirpath = path.dirname(f)
    if not os.access(dirpath, os.R_OK):
        os.makedirs(dirpath)

    try:
        with open(f, &#39;w+&#39;, encoding=&#39;utf-8&#39;) as w:
            if ext == &#39;.html&#39;:
                w.write(m.html(**kwargs))
            elif ext == &#39;.md&#39;:
                w.write(m.text(**kwargs))
    except Exception:
        try:
            os.unlink(f)
        except Exception:
            pass
        raise

    for submodule in m.submodules():
        write_files(submodule, ext=ext, **kwargs)


def _flatten_submodules(modules: Sequence[pdoc.Module]):
    for module in modules:
        yield module
        for submodule in module.submodules():
            yield from _flatten_submodules((submodule,))


def print_pdf(modules, **kwargs):
    modules = list(_flatten_submodules(modules))
    print(pdoc._render_template(&#39;/pdf.mako&#39;, modules=modules, **kwargs))


def _warn_deprecated(option, alternative=&#39;&#39;, use_config_mako=False):
    msg = &#39;Program option `{}` is deprecated.&#39;.format(option)
    if alternative:
        msg += &#39; Use `&#39; + alternative + &#39;`&#39;
        if use_config_mako:
            msg += &#39; or override config.mako template&#39;
        msg += &#39;.&#39;
    warn(msg, DeprecationWarning, stacklevel=2)


def main(_args=None):
    &#34;&#34;&#34; Command-line entry point &#34;&#34;&#34;
    global args
    args = _args or parser.parse_args()

    warnings.simplefilter(&#34;once&#34;, DeprecationWarning)

    if args.close_stdin:
        sys.stdin.close()

    if (args.html or args.http) and not args.output_dir:
        args.output_dir = &#39;html&#39;

    if args.html_dir:
        _warn_deprecated(&#39;--html-dir&#39;, &#39;--output-dir&#39;)
        args.output_dir = args.html_dir
    if args.overwrite:
        _warn_deprecated(&#39;--overwrite&#39;, &#39;--force&#39;)
        args.force = args.overwrite

    template_config = {}
    for config_str in args.config:
        try:
            key, value = config_str.split(&#39;=&#39;, 1)
            value = ast.literal_eval(value)
            template_config[key] = value
        except Exception:
            raise ValueError(
                &#39;Error evaluating --config statement &#34;{}&#34;. &#39;
                &#39;Make sure string values are quoted?&#39;
                .format(config_str)
            )

    if args.html_no_source:
        _warn_deprecated(&#39;--html-no-source&#39;, &#39;-c show_source_code=False&#39;, True)
        template_config[&#39;show_source_code&#39;] = False
    if args.link_prefix:
        _warn_deprecated(&#39;--link-prefix&#39;, &#39;-c link_prefix=&#34;foo&#34;&#39;, True)
        template_config[&#39;link_prefix&#39;] = args.link_prefix
    if args.external_links:
        _warn_deprecated(&#39;--external-links&#39;)
        template_config[&#39;external_links&#39;] = True

    if args.template_dir is not None:
        if not path.isdir(args.template_dir):
            print(&#39;Error: Template dir {!r} is not a directory&#39;.format(args.template_dir),
                  file=sys.stderr)
            sys.exit(1)
        pdoc.tpl_lookup.directories.insert(0, args.template_dir)

    # Support loading modules specified as python paths relative to cwd
    sys.path.append(os.getcwd())

    # Virtual environment handling for pdoc script run from system site
    try:
        venv_dir = os.environ[&#39;VIRTUAL_ENV&#39;]
    except KeyError:
        pass  # pdoc was not invoked while in a virtual environment
    else:
        from distutils.sysconfig import get_python_lib
        sys.path.append(get_python_lib(prefix=venv_dir))

    if args.http:
        template_config[&#39;link_prefix&#39;] = &#34;/&#34;

        # Run the HTTP server.
        WebDoc.args = args  # Pass params to HTTPServer xP
        WebDoc.template_config = template_config

        host, _, port = args.http.partition(&#39;:&#39;)
        host = host or DEFAULT_HOST
        port = int(port or DEFAULT_PORT)

        print(&#39;Starting pdoc server on {}:{}&#39;.format(host, port), file=sys.stderr)
        httpd = HTTPServer((host, port), WebDoc)
        print(&#34;pdoc server ready at http://%s:%d&#34; % (host, port), file=sys.stderr)

        # Allow tests to perform `pdoc.cli._httpd.shutdown()`
        global _httpd
        _httpd = httpd

        try:
            httpd.serve_forever()
        finally:
            httpd.server_close()
            sys.exit(0)

    docfilter = None
    if args.filter and args.filter.strip():
        def docfilter(obj, _filters=args.filter.strip().split(&#39;,&#39;)):
            return any(f in obj.refname or
                       isinstance(obj, pdoc.Class) and f in obj.doc
                       for f in _filters)

    modules = [pdoc.Module(module, docfilter=docfilter)
               for module in args.modules]
    pdoc.link_inheritance()

    if args.pdf:
        print_pdf(modules, **template_config)
        print(&#34;&#34;&#34;
PDF-ready markdown written to standard output.
                              ^^^^^^^^^^^^^^^
Convert this file to PDF using e.g. Pandoc:

    pandoc --metadata=title:&#34;MyProject Documentation&#34;             \\
           --toc --toc-depth=4 --from=markdown+abbreviations      \\
           --pdf-engine=xelatex --variable=mainfont:&#34;DejaVu Sans&#34; \\
           --output=pdf.pdf pdf.md

or using Python-Markdown and Chrome/Chromium/WkHtmlToPDF:

    markdown_py --extension=meta         \\
                --extension=abbr         \\
                --extension=attr_list    \\
                --extension=def_list     \\
                --extension=fenced_code  \\
                --extension=footnotes    \\
                --extension=tables       \\
                --extension=admonition   \\
                --extension=smarty       \\
                --extension=toc          \\
                pdf.md &gt; pdf.html

    chromium --headless --disable-gpu --print-to-pdf=pdf.pdf pdf.html

    wkhtmltopdf -s A4 --print-media-type pdf.html pdf.pdf

or similar, at your own discretion.&#34;&#34;&#34;,
              file=sys.stderr)
        sys.exit(0)

    for module in modules:
        if args.html:
            _quit_if_exists(module, ext=&#39;.html&#39;)
            write_files(module, ext=&#39;.html&#39;, **template_config)
        elif args.output_dir:  # Generate text files
            _quit_if_exists(module, ext=&#39;.md&#39;)
            write_files(module, ext=&#39;.md&#39;, **template_config)
        else:
            sys.stdout.write(module.text(**template_config))
            # Two blank lines between two modules&#39; texts
            sys.stdout.write(os.linesep * (1 + 2 * int(module != modules[-1])))


if __name__ == &#34;__main__&#34;:
    main(parser.parse_args())</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pdoc.cli.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"><p>Command-line entry point</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdoc3/pdoc/blob/c9d9118e1a2df4debc485e2d5b2118cd79f60994/pdoc/cli.py#L354-L496" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def main(_args=None):
    &#34;&#34;&#34; Command-line entry point &#34;&#34;&#34;
    global args
    args = _args or parser.parse_args()

    warnings.simplefilter(&#34;once&#34;, DeprecationWarning)

    if args.close_stdin:
        sys.stdin.close()

    if (args.html or args.http) and not args.output_dir:
        args.output_dir = &#39;html&#39;

    if args.html_dir:
        _warn_deprecated(&#39;--html-dir&#39;, &#39;--output-dir&#39;)
        args.output_dir = args.html_dir
    if args.overwrite:
        _warn_deprecated(&#39;--overwrite&#39;, &#39;--force&#39;)
        args.force = args.overwrite

    template_config = {}
    for config_str in args.config:
        try:
            key, value = config_str.split(&#39;=&#39;, 1)
            value = ast.literal_eval(value)
            template_config[key] = value
        except Exception:
            raise ValueError(
                &#39;Error evaluating --config statement &#34;{}&#34;. &#39;
                &#39;Make sure string values are quoted?&#39;
                .format(config_str)
            )

    if args.html_no_source:
        _warn_deprecated(&#39;--html-no-source&#39;, &#39;-c show_source_code=False&#39;, True)
        template_config[&#39;show_source_code&#39;] = False
    if args.link_prefix:
        _warn_deprecated(&#39;--link-prefix&#39;, &#39;-c link_prefix=&#34;foo&#34;&#39;, True)
        template_config[&#39;link_prefix&#39;] = args.link_prefix
    if args.external_links:
        _warn_deprecated(&#39;--external-links&#39;)
        template_config[&#39;external_links&#39;] = True

    if args.template_dir is not None:
        if not path.isdir(args.template_dir):
            print(&#39;Error: Template dir {!r} is not a directory&#39;.format(args.template_dir),
                  file=sys.stderr)
            sys.exit(1)
        pdoc.tpl_lookup.directories.insert(0, args.template_dir)

    # Support loading modules specified as python paths relative to cwd
    sys.path.append(os.getcwd())

    # Virtual environment handling for pdoc script run from system site
    try:
        venv_dir = os.environ[&#39;VIRTUAL_ENV&#39;]
    except KeyError:
        pass  # pdoc was not invoked while in a virtual environment
    else:
        from distutils.sysconfig import get_python_lib
        sys.path.append(get_python_lib(prefix=venv_dir))

    if args.http:
        template_config[&#39;link_prefix&#39;] = &#34;/&#34;

        # Run the HTTP server.
        WebDoc.args = args  # Pass params to HTTPServer xP
        WebDoc.template_config = template_config

        host, _, port = args.http.partition(&#39;:&#39;)
        host = host or DEFAULT_HOST
        port = int(port or DEFAULT_PORT)

        print(&#39;Starting pdoc server on {}:{}&#39;.format(host, port), file=sys.stderr)
        httpd = HTTPServer((host, port), WebDoc)
        print(&#34;pdoc server ready at http://%s:%d&#34; % (host, port), file=sys.stderr)

        # Allow tests to perform `pdoc.cli._httpd.shutdown()`
        global _httpd
        _httpd = httpd

        try:
            httpd.serve_forever()
        finally:
            httpd.server_close()
            sys.exit(0)

    docfilter = None
    if args.filter and args.filter.strip():
        def docfilter(obj, _filters=args.filter.strip().split(&#39;,&#39;)):
            return any(f in obj.refname or
                       isinstance(obj, pdoc.Class) and f in obj.doc
                       for f in _filters)

    modules = [pdoc.Module(module, docfilter=docfilter)
               for module in args.modules]
    pdoc.link_inheritance()

    if args.pdf:
        print_pdf(modules, **template_config)
        print(&#34;&#34;&#34;
PDF-ready markdown written to standard output.
                              ^^^^^^^^^^^^^^^
Convert this file to PDF using e.g. Pandoc:

    pandoc --metadata=title:&#34;MyProject Documentation&#34;             \\
           --toc --toc-depth=4 --from=markdown+abbreviations      \\
           --pdf-engine=xelatex --variable=mainfont:&#34;DejaVu Sans&#34; \\
           --output=pdf.pdf pdf.md

or using Python-Markdown and Chrome/Chromium/WkHtmlToPDF:

    markdown_py --extension=meta         \\
                --extension=abbr         \\
                --extension=attr_list    \\
                --extension=def_list     \\
                --extension=fenced_code  \\
                --extension=footnotes    \\
                --extension=tables       \\
                --extension=admonition   \\
                --extension=smarty       \\
                --extension=toc          \\
                pdf.md &gt; pdf.html

    chromium --headless --disable-gpu --print-to-pdf=pdf.pdf pdf.html

    wkhtmltopdf -s A4 --print-media-type pdf.html pdf.pdf

or similar, at your own discretion.&#34;&#34;&#34;,
              file=sys.stderr)
        sys.exit(0)

    for module in modules:
        if args.html:
            _quit_if_exists(module, ext=&#39;.html&#39;)
            write_files(module, ext=&#39;.html&#39;, **template_config)
        elif args.output_dir:  # Generate text files
            _quit_if_exists(module, ext=&#39;.md&#39;)
            write_files(module, ext=&#39;.md&#39;, **template_config)
        else:
            sys.stdout.write(module.text(**template_config))
            # Two blank lines between two modules&#39; texts
            sys.stdout.write(os.linesep * (1 + 2 * int(module != modules[-1])))</code></pre>
</details>
</dd>
<dt id="pdoc.cli.module_path"><code class="name flex">
<span>def <span class="ident">module_path</span></span>(<span>m, ext)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdoc3/pdoc/blob/c9d9118e1a2df4debc485e2d5b2118cd79f60994/pdoc/cli.py#L288-L289" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def module_path(m: pdoc.Module, ext: str):
    return path.join(args.output_dir, *re.sub(r&#39;\.html$&#39;, ext, m.url()).split(&#39;/&#39;))</code></pre>
</details>
</dd>
<dt id="pdoc.cli.print_pdf"><code class="name flex">
<span>def <span class="ident">print_pdf</span></span>(<span>modules, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdoc3/pdoc/blob/c9d9118e1a2df4debc485e2d5b2118cd79f60994/pdoc/cli.py#L339-L341" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def print_pdf(modules, **kwargs):
    modules = list(_flatten_submodules(modules))
    print(pdoc._render_template(&#39;/pdf.mako&#39;, modules=modules, **kwargs))</code></pre>
</details>
</dd>
<dt id="pdoc.cli.write_files"><code class="name flex">
<span>def <span class="ident">write_files</span></span>(<span>m, ext, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdoc3/pdoc/blob/c9d9118e1a2df4debc485e2d5b2118cd79f60994/pdoc/cli.py#L307-L329" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def write_files(m: pdoc.Module, ext: str, **kwargs):
    assert ext in (&#39;.html&#39;, &#39;.md&#39;)
    f = module_path(m, ext=ext)

    dirpath = path.dirname(f)
    if not os.access(dirpath, os.R_OK):
        os.makedirs(dirpath)

    try:
        with open(f, &#39;w+&#39;, encoding=&#39;utf-8&#39;) as w:
            if ext == &#39;.html&#39;:
                w.write(m.html(**kwargs))
            elif ext == &#39;.md&#39;:
                w.write(m.text(**kwargs))
    except Exception:
        try:
            os.unlink(f)
        except Exception:
            pass
        raise

    for submodule in m.submodules():
        write_files(submodule, ext=ext, **kwargs)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pdoc.cli.WebDoc"><code class="flex name class">
<span>class <span class="ident">WebDoc</span></span>
<span>(</span><span>request, client_address, server)</span>
</code></dt>
<dd>
<section class="desc"><p>HTTP request handler base class.</p>
<p>The following explanation of HTTP serves to guide you through the
code as well as to expose any misunderstandings I may have about
HTTP (so you don't need to read the code to figure out I'm wrong
:-).</p>
<p>HTTP (HyperText Transfer Protocol) is an extensible protocol on
top of a reliable stream transport (e.g. TCP/IP).
The protocol
recognizes three parts to a request:</p>
<ol>
<li>One line identifying the request type and path</li>
<li>An optional set of RFC-822-style headers</li>
<li>An optional data part</li>
</ol>
<p>The headers and data are separated by a blank line.</p>
<p>The first line of the request has the form</p>
<p><command> <path> <version></p>
<p>where <command> is a (case-sensitive) keyword such as GET or POST,
<path> is a string containing path information for the request,
and <version> should be the string "HTTP/1.0" or "HTTP/1.1".
<path> is encoded using the URL encoding scheme (using %xx to signify
the ASCII character with hex code xx).</p>
<p>The specification specifies that lines are separated by CRLF but
for compatibility with the widest range of clients recommends
servers also handle LF.
Similarly, whitespace in the request line
is treated sensibly (allowing multiple spaces between components
and allowing trailing whitespace).</p>
<p>Similarly, for output, lines ought to be separated by CRLF pairs
but most clients grok LF characters just fine.</p>
<p>If the first line of the request has the form</p>
<p><command> <path></p>
<p>(i.e. <version> is left out) then this is assumed to be an HTTP
0.9 request; this form has no optional headers and data part and
the reply consists of just the data.</p>
<p>The reply form of the HTTP 1.x protocol again has three parts:</p>
<ol>
<li>One line giving the response code</li>
<li>An optional set of RFC-822-style headers</li>
<li>The data</li>
</ol>
<p>Again, the headers and data are separated by a blank line.</p>
<p>The response code line has the form</p>
<p><version> <responsecode> <responsestring></p>
<p>where <version> is the protocol version ("HTTP/1.0" or "HTTP/1.1"),
<responsecode> is a 3-digit response code indicating success or
failure of the request, and <responsestring> is an optional
human-readable string explaining what the response code means.</p>
<p>This server parses the request and the headers, and then calls a
function specific to the request type (<command>).
Specifically,
a request SPAM will be handled by a method do_SPAM().
If no
such method exists the server sends an error response to the
client.
If it exists, it is called with no arguments:</p>
<p>do_SPAM()</p>
<p>Note that the request name is case sensitive (i.e. SPAM and spam
are different requests).</p>
<p>The various request details are stored in instance variables:</p>
<ul>
<li>
<p>client_address is the client IP address in the form (host,
port);</p>
</li>
<li>
<p>command, path and version are the broken-down request line;</p>
</li>
<li>
<p>headers is an instance of email.message.Message (or a derived
class) containing the header information;</p>
</li>
<li>
<p>rfile is a file object open for reading positioned at the
start of the optional input data part;</p>
</li>
<li>
<p>wfile is a file object open for writing.</p>
</li>
</ul>
<p>IT IS IMPORTANT TO ADHERE TO THE PROTOCOL FOR WRITING!</p>
<p>The first thing to be written must be the response line.
Then
follow 0 or more header lines, then a blank line, and then the
actual data (if any).
The meaning of the header lines depends on
the command executed by the server; in most cases, when data is
returned, there should be at least one header line of the form</p>
<p>Content-type: <type>/<subtype></p>
<p>where <type> and <subtype> should be registered MIME types,
e.g. "text/html" or "text/plain".</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdoc3/pdoc/blob/c9d9118e1a2df4debc485e2d5b2118cd79f60994/pdoc/cli.py#L147-L285" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class WebDoc(BaseHTTPRequestHandler):
    args = None  # Set before server instantiated
    template_config = None

    def do_HEAD(self):
        status = 200
        if self.path != &#34;/&#34;:
            status = self.check_modified()

        self.send_response(status)
        self.send_header(&#34;Content-type&#34;, &#34;text/html; charset=utf-8&#34;)
        self.end_headers()

    def check_modified(self):
        try:
            module = pdoc.import_module(self.import_path_from_req_url)
            new_etag = str(os.stat(module.__file__).st_mtime)
        except ImportError:
            return 404

        old_etag = self.headers.get(&#39;If-None-Match&#39;, new_etag)
        if old_etag == new_etag:
            # Don&#39;t log repeating checks
            self.log_request = lambda *args, **kwargs: None
            return 304

        return 205

    def do_GET(self):
        # Deny favicon shortcut early.
        if self.path == &#34;/favicon.ico&#34;:
            return None

        importlib.invalidate_caches()
        code = 200
        if self.path == &#34;/&#34;:
            modules = [pdoc.import_module(module, reload=True)
                       for module in self.args.modules]
            modules = sorted((module.__name__, inspect.getdoc(module))
                             for module in modules)
            out = pdoc._render_template(&#39;/html.mako&#39;,
                                        modules=modules,
                                        **self.template_config)
        elif self.path.endswith(&#34;.ext&#34;):
            # External links are a bit weird. You should view them as a giant
            # hack. Basically, the idea is to &#34;guess&#34; where something lives
            # when documenting another module and hope that guess can actually
            # track something down in a more global context.
            #
            # The idea here is to start specific by looking for HTML that
            # exists that matches the full external path given. Then trim off
            # one component at the end and try again.
            #
            # If no HTML is found, then we ask `pdoc` to do its thang on the
            # parent module in the external path. If all goes well, that
            # module will then be able to find the external identifier.

            import_path = self.path[:-4].lstrip(&#34;/&#34;)
            resolved = self.resolve_ext(import_path)
            if resolved is None:  # Try to generate the HTML...
                print(&#34;Generating HTML for %s on the fly...&#34; % import_path, file=sys.stderr)
                try:
                    out = pdoc.html(import_path.split(&#34;.&#34;)[0], **self.template_config)
                except Exception as e:
                    print(&#39;Error generating docs: {}&#39;.format(e), file=sys.stderr)
                    # All hope is lost.
                    code = 404
                    out = &#34;External identifier &lt;code&gt;%s&lt;/code&gt; not found.&#34; % import_path
            else:
                return self.redirect(resolved)
        # Redirect &#39;/pdoc&#39; to &#39;/pdoc/&#39; so that relative links work
        # (results in &#39;/pdoc/cli.html&#39; instead of &#39;cli.html&#39;)
        elif not self.path.endswith((&#39;/&#39;, &#39;.html&#39;)):
            return self.redirect(self.path + &#39;/&#39;)
        # Redirect &#39;/pdoc/index.html&#39; to &#39;/pdoc/&#39; so it&#39;s more pretty
        elif self.path.endswith(pdoc._URL_PACKAGE_SUFFIX):
            return self.redirect(self.path[:-len(pdoc._URL_PACKAGE_SUFFIX)] + &#39;/&#39;)
        else:
            try:
                out = self.html()
            except ImportError:
                code = 404
                out = &#34;Module &lt;code&gt;%s&lt;/code&gt; not found.&#34; % self.import_path_from_req_url

        self.send_response(code)
        self.send_header(&#34;Content-type&#34;, &#34;text/html; charset=utf-8&#34;)
        self.end_headers()
        self.echo(out)

    def redirect(self, location):
        self.send_response(302)
        self.send_header(&#34;Location&#34;, location)
        self.end_headers()

    def echo(self, s):
        self.wfile.write(s.encode(&#34;utf-8&#34;))

    def html(self):
        &#34;&#34;&#34;
        Retrieves and sends the HTML belonging to the path given in
        URL. This method is smart and will look for HTML files already
        generated and account for whether they are stale compared to
        the source code.
        &#34;&#34;&#34;
        return pdoc.html(self.import_path_from_req_url,
                         reload=True, http_server=True, external_links=True,
                         **self.template_config)

    def resolve_ext(self, import_path):
        def exists(p):
            p = path.join(args.output_dir, p)
            pkg = path.join(p, pdoc._URL_PACKAGE_SUFFIX.lstrip(&#39;/&#39;))
            mod = p + pdoc._URL_MODULE_SUFFIX

            if path.isfile(pkg):
                return pkg[len(args.output_dir):]
            elif path.isfile(mod):
                return mod[len(args.output_dir):]
            return None

        parts = import_path.split(&#34;.&#34;)
        for i in range(len(parts), 0, -1):
            p = path.join(*parts[0:i])
            realp = exists(p)
            if realp is not None:
                return &#34;/%s#%s&#34; % (realp.lstrip(&#34;/&#34;), import_path)
        return None

    @property
    def import_path_from_req_url(self):
        pth = self.path.split(&#39;#&#39;)[0].lstrip(&#39;/&#39;)
        for suffix in (&#39;/&#39;,
                       pdoc._URL_PACKAGE_SUFFIX,
                       pdoc._URL_INDEX_MODULE_SUFFIX,
                       pdoc._URL_MODULE_SUFFIX):
            if pth.endswith(suffix):
                pth = pth[:-len(suffix)]
                break
        return pth.replace(&#39;/&#39;, &#39;.&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>http.server.BaseHTTPRequestHandler</li>
<li>socketserver.StreamRequestHandler</li>
<li>socketserver.BaseRequestHandler</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="pdoc.cli.WebDoc.args"><code class="name">var <span class="ident">args</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="pdoc.cli.WebDoc.template_config"><code class="name">var <span class="ident">template_config</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="pdoc.cli.WebDoc.import_path_from_req_url"><code class="name">var <span class="ident">import_path_from_req_url</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdoc3/pdoc/blob/c9d9118e1a2df4debc485e2d5b2118cd79f60994/pdoc/cli.py#L275-L285" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def import_path_from_req_url(self):
    pth = self.path.split(&#39;#&#39;)[0].lstrip(&#39;/&#39;)
    for suffix in (&#39;/&#39;,
                   pdoc._URL_PACKAGE_SUFFIX,
                   pdoc._URL_INDEX_MODULE_SUFFIX,
                   pdoc._URL_MODULE_SUFFIX):
        if pth.endswith(suffix):
            pth = pth[:-len(suffix)]
            break
    return pth.replace(&#39;/&#39;, &#39;.&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pdoc.cli.WebDoc.check_modified"><code class="name flex">
<span>def <span class="ident">check_modified</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdoc3/pdoc/blob/c9d9118e1a2df4debc485e2d5b2118cd79f60994/pdoc/cli.py#L160-L173" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def check_modified(self):
    try:
        module = pdoc.import_module(self.import_path_from_req_url)
        new_etag = str(os.stat(module.__file__).st_mtime)
    except ImportError:
        return 404

    old_etag = self.headers.get(&#39;If-None-Match&#39;, new_etag)
    if old_etag == new_etag:
        # Don&#39;t log repeating checks
        self.log_request = lambda *args, **kwargs: None
        return 304

    return 205</code></pre>
</details>
</dd>
<dt id="pdoc.cli.WebDoc.do_GET"><code class="name flex">
<span>def <span class="ident">do_GET</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdoc3/pdoc/blob/c9d9118e1a2df4debc485e2d5b2118cd79f60994/pdoc/cli.py#L175-L234" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def do_GET(self):
    # Deny favicon shortcut early.
    if self.path == &#34;/favicon.ico&#34;:
        return None

    importlib.invalidate_caches()
    code = 200
    if self.path == &#34;/&#34;:
        modules = [pdoc.import_module(module, reload=True)
                   for module in self.args.modules]
        modules = sorted((module.__name__, inspect.getdoc(module))
                         for module in modules)
        out = pdoc._render_template(&#39;/html.mako&#39;,
                                    modules=modules,
                                    **self.template_config)
    elif self.path.endswith(&#34;.ext&#34;):
        # External links are a bit weird. You should view them as a giant
        # hack. Basically, the idea is to &#34;guess&#34; where something lives
        # when documenting another module and hope that guess can actually
        # track something down in a more global context.
        #
        # The idea here is to start specific by looking for HTML that
        # exists that matches the full external path given. Then trim off
        # one component at the end and try again.
        #
        # If no HTML is found, then we ask `pdoc` to do its thang on the
        # parent module in the external path. If all goes well, that
        # module will then be able to find the external identifier.

        import_path = self.path[:-4].lstrip(&#34;/&#34;)
        resolved = self.resolve_ext(import_path)
        if resolved is None:  # Try to generate the HTML...
            print(&#34;Generating HTML for %s on the fly...&#34; % import_path, file=sys.stderr)
            try:
                out = pdoc.html(import_path.split(&#34;.&#34;)[0], **self.template_config)
            except Exception as e:
                print(&#39;Error generating docs: {}&#39;.format(e), file=sys.stderr)
                # All hope is lost.
                code = 404
                out = &#34;External identifier &lt;code&gt;%s&lt;/code&gt; not found.&#34; % import_path
        else:
            return self.redirect(resolved)
    # Redirect &#39;/pdoc&#39; to &#39;/pdoc/&#39; so that relative links work
    # (results in &#39;/pdoc/cli.html&#39; instead of &#39;cli.html&#39;)
    elif not self.path.endswith((&#39;/&#39;, &#39;.html&#39;)):
        return self.redirect(self.path + &#39;/&#39;)
    # Redirect &#39;/pdoc/index.html&#39; to &#39;/pdoc/&#39; so it&#39;s more pretty
    elif self.path.endswith(pdoc._URL_PACKAGE_SUFFIX):
        return self.redirect(self.path[:-len(pdoc._URL_PACKAGE_SUFFIX)] + &#39;/&#39;)
    else:
        try:
            out = self.html()
        except ImportError:
            code = 404
            out = &#34;Module &lt;code&gt;%s&lt;/code&gt; not found.&#34; % self.import_path_from_req_url

    self.send_response(code)
    self.send_header(&#34;Content-type&#34;, &#34;text/html; charset=utf-8&#34;)
    self.end_headers()
    self.echo(out)</code></pre>
</details>
</dd>
<dt id="pdoc.cli.WebDoc.do_HEAD"><code class="name flex">
<span>def <span class="ident">do_HEAD</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdoc3/pdoc/blob/c9d9118e1a2df4debc485e2d5b2118cd79f60994/pdoc/cli.py#L151-L158" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def do_HEAD(self):
    status = 200
    if self.path != &#34;/&#34;:
        status = self.check_modified()

    self.send_response(status)
    self.send_header(&#34;Content-type&#34;, &#34;text/html; charset=utf-8&#34;)
    self.end_headers()</code></pre>
</details>
</dd>
<dt id="pdoc.cli.WebDoc.echo"><code class="name flex">
<span>def <span class="ident">echo</span></span>(<span>self, s)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdoc3/pdoc/blob/c9d9118e1a2df4debc485e2d5b2118cd79f60994/pdoc/cli.py#L241-L242" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def echo(self, s):
    self.wfile.write(s.encode(&#34;utf-8&#34;))</code></pre>
</details>
</dd>
<dt id="pdoc.cli.WebDoc.html"><code class="name flex">
<span>def <span class="ident">html</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Retrieves and sends the HTML belonging to the path given in
URL. This method is smart and will look for HTML files already
generated and account for whether they are stale compared to
the source code.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdoc3/pdoc/blob/c9d9118e1a2df4debc485e2d5b2118cd79f60994/pdoc/cli.py#L244-L253" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def html(self):
    &#34;&#34;&#34;
    Retrieves and sends the HTML belonging to the path given in
    URL. This method is smart and will look for HTML files already
    generated and account for whether they are stale compared to
    the source code.
    &#34;&#34;&#34;
    return pdoc.html(self.import_path_from_req_url,
                     reload=True, http_server=True, external_links=True,
                     **self.template_config)</code></pre>
</details>
</dd>
<dt id="pdoc.cli.WebDoc.redirect"><code class="name flex">
<span>def <span class="ident">redirect</span></span>(<span>self, location)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdoc3/pdoc/blob/c9d9118e1a2df4debc485e2d5b2118cd79f60994/pdoc/cli.py#L236-L239" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def redirect(self, location):
    self.send_response(302)
    self.send_header(&#34;Location&#34;, location)
    self.end_headers()</code></pre>
</details>
</dd>
<dt id="pdoc.cli.WebDoc.resolve_ext"><code class="name flex">
<span>def <span class="ident">resolve_ext</span></span>(<span>self, import_path)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdoc3/pdoc/blob/c9d9118e1a2df4debc485e2d5b2118cd79f60994/pdoc/cli.py#L255-L273" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def resolve_ext(self, import_path):
    def exists(p):
        p = path.join(args.output_dir, p)
        pkg = path.join(p, pdoc._URL_PACKAGE_SUFFIX.lstrip(&#39;/&#39;))
        mod = p + pdoc._URL_MODULE_SUFFIX

        if path.isfile(pkg):
            return pkg[len(args.output_dir):]
        elif path.isfile(mod):
            return mod[len(args.output_dir):]
        return None

    parts = import_path.split(&#34;.&#34;)
    for i in range(len(parts), 0, -1):
        p = path.join(*parts[0:i])
        realp = exists(p)
        if realp is not None:
            return &#34;/%s#%s&#34; % (realp.lstrip(&#34;/&#34;), import_path)
    return None</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="pdoc Home" href="https://pdoc3.github.io/pdoc/">
<img src="https://pdoc3.github.io/pdoc/logo.png" alt=""> pdoc
</a>
</header>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pdoc" href="index.html">pdoc</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pdoc.cli.main" href="#pdoc.cli.main">main</a></code></li>
<li><code><a title="pdoc.cli.module_path" href="#pdoc.cli.module_path">module_path</a></code></li>
<li><code><a title="pdoc.cli.print_pdf" href="#pdoc.cli.print_pdf">print_pdf</a></code></li>
<li><code><a title="pdoc.cli.write_files" href="#pdoc.cli.write_files">write_files</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pdoc.cli.WebDoc" href="#pdoc.cli.WebDoc">WebDoc</a></code></h4>
<ul class="">
<li><code><a title="pdoc.cli.WebDoc.args" href="#pdoc.cli.WebDoc.args">args</a></code></li>
<li><code><a title="pdoc.cli.WebDoc.check_modified" href="#pdoc.cli.WebDoc.check_modified">check_modified</a></code></li>
<li><code><a title="pdoc.cli.WebDoc.do_GET" href="#pdoc.cli.WebDoc.do_GET">do_GET</a></code></li>
<li><code><a title="pdoc.cli.WebDoc.do_HEAD" href="#pdoc.cli.WebDoc.do_HEAD">do_HEAD</a></code></li>
<li><code><a title="pdoc.cli.WebDoc.echo" href="#pdoc.cli.WebDoc.echo">echo</a></code></li>
<li><code><a title="pdoc.cli.WebDoc.html" href="#pdoc.cli.WebDoc.html">html</a></code></li>
<li><code><a title="pdoc.cli.WebDoc.import_path_from_req_url" href="#pdoc.cli.WebDoc.import_path_from_req_url">import_path_from_req_url</a></code></li>
<li><code><a title="pdoc.cli.WebDoc.redirect" href="#pdoc.cli.WebDoc.redirect">redirect</a></code></li>
<li><code><a title="pdoc.cli.WebDoc.resolve_ext" href="#pdoc.cli.WebDoc.resolve_ext">resolve_ext</a></code></li>
<li><code><a title="pdoc.cli.WebDoc.template_config" href="#pdoc.cli.WebDoc.template_config">template_config</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p><span style="color:#ddd">&#21328;</span></p>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.4</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
<script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-43663477-5','auto');ga('require','cleanUrlTracker',{indexFilename:'index.html',trailingSlash:'add'});ga('require','outboundLinkTracker',{events:['click','auxclick','contextmenu']});ga('require','maxScrollTracker');ga('require','pageVisibilityTracker');ga('send','pageview');setTimeout(function(){ga('send','event','pageview','view')},15000);</script><script async src='https://www.google-analytics.com/analytics.js'></script><script async src='https://cdnjs.cloudflare.com/ajax/libs/autotrack/2.4.1/autotrack.js'></script></body>
</html>